
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Manifest</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/admin/es2015/cheerio-mobi-ts10/undefined" />
  </head>
   <body>
<h2 id="manifest">Manifest<a href="#manifest" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>Once your application hits the browser in the form of <code>index.html</code> file, some bundles and a variety of other assets required by your application must be loaded and linked somehow. That <code>/src</code> directory you meticulously laid out is now bundled, minified and maybe even split into smaller chunks for lazy-loading by webpack&apos;s <a href="/configuration/optimization/"><code>optimization</code></a>. So how does webpack manage the interaction between all of your required modules? This is where the manifest data comes in...</p>
<p>As the compiler enters, resolves, and maps out your application, it keeps detailed notes on all your modules. This collection of data is called the &quot;Manifest,&quot; and it&apos;s what the runtime will use to resolve and load modules once they&apos;ve been bundled and shipped to the browser. No matter which <a href="/api/module-methods">module syntax</a> you have chosen, those <code>import</code> or <code>require</code> statements have now become <code>__webpack_require__</code> methods that point to module identifiers. Using the data in the manifest, the runtime will be able to find out where to retrieve the modules behind the identifiers.</p>
</body>
</html>