
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Generation</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/admin/es2015/cheerio-mobi-ts10/undefined" />
  </head>
   <body>
<div class="chapter" lang="en">
    <div class="titlepage">
        <div>
            <h2 class="title"><a id="generationchapter">Chapter&#xFFFD;9.&#xFFFD;Generation</a></h2>
        </div>
        <div>
            <h3 class="subtitle"><i>Pushing the Specification Level Upwards</i></h3>
        </div>
    </div>
    <div xmlns class="epigraph"><i>
            <p xmlns="http://www.w3.org/1999/xhtml">The programmer at wit&apos;s end ... can often do best by
                disentangling himself from his code, rearing back, and
                contemplating his data. Representation is the essence of
                programming.</p>
        </i><span>--<i><span xmlns="http://www.w3.org/1999/xhtml" class="attribution">
                    <span class="author">Fred Brooks</span>
                    <i>The Mythical Man-Month, Anniversary Edition (1975-1995), p.&#xFFFD;103</i>
                    </span></i></span></div>
    <p>In <a href="philosophychapter.html" title="Chapter&#xFFFD;1.&#xFFFD;Philosophy">Chapter&#xFFFD;1</a> we
        observed that human beings are better at visualizing data than they
        are at reasoning about control flow. We recapitulate: To see this,
        compare the expressiveness and explanatory power of a diagram of a
        fifty-node pointer tree with a flowchart of a fifty-line program. Or
        (better) of an array initializer expressing a conversion table with an
        equivalent switch statement. The difference in
        transparency</p>
    <p>Data is more tractable than program logic. That&apos;s
        true whether the data is an ordinary table, a declarative markup
        language, a templating system, or a set of macros that will expand to
        program logic. It&apos;s good practice to move as much of the complexity
        in your design as possible away from procedural code and into
        data, and good practice to pick data representations that are
        convenient for humans to maintain and manipulate. Translating
        those representations into forms that are convenient for machines
        to process is another job for machines, not for humans.</p>
    <div class="blockquote">
        <table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
            <tr>
                <td width="10%" valign="top">&#xFFFD;</td>
                <td width="80%" valign="top">
                    <p>Another important advantage of higher-level, more declarative
                        notations is that they lend themselves better to compile-time checking.
                        Procedural notations inherently have complex runtime behavior which is
                        difficult to analyze at compile time. Declarative notations give the
                        implementation much more leverage for finding mistakes, by permitting much
                        more thorough understanding of the intended behavior.</p>
                </td>
                <td width="10%" valign="top">&#xFFFD;</td>
            </tr>
            <tr>
                <td colspan="2" align="right" valign="top">--<span class="attribution">
                        <span class="author">Henry Spencer</span>
                        </span></td>
                <td width="10%" valign="top">&#xFFFD;</td>
            </tr>
        </table>
    </div>
    <p>These insights ground in theory a set of practices that have
        always been an important part of the Unix programmer&apos;s toolkit &#x2014;
        very high-level languages, data-driven programming, code generators,
        and domain-specific minilanguages. What unifies these is that they
        are all ways of lifting the generation of code up some levels, so that
        specifications can be smaller. We&apos;ve previously noted that defect
        densities tend to be nearly constant across programming languages; all
        these practices mean that whatever malign forces generate our bugs
        will get fewer lines to wreak their havoc on.</p>
    <p>In <a href="minilanguageschapter.html" title="Chapter&#xFFFD;8.&#xFFFD;Minilanguages">Chapter&#xFFFD;8</a> we
        discussed the uses of domain-specific minilanguages. In <a href="languageschapter.html" title="Chapter&#xFFFD;14.&#xFFFD;Languages">Chapter&#xFFFD;14</a> we&apos;ll make the argument for
        very-high-level languages</p>
    <div class="footnotes"><br>
        <hr width="100" align="left">
        <div class="footnote">
            <p><sup>[<a id="ftn.id2939543" href="generationchapter.html#id2939543">97</a>] </sup>For further development of this point see
                [<a href="apb.html#Bentley" title="[Bentley]">Bentley</a>].</p>
        </div>
    </div>
</div>
</body>
</html>