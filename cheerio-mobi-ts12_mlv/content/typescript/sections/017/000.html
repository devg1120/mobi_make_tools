
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>
                    StyleGuide
                </title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/gusa1120/es2015/cheerio-mobi-ts12_mlv/undefined" />
  </head>
   <body>
<h1 id="typescript-styleguide-and-coding-conventions">TypeScript StyleGuide and Coding Conventions</h1>
<blockquote>
    <p>An unofficial TypeScript StyleGuide</p>
</blockquote>
<p>People have asked me for my opinions on this. Personally I don&apos;t enforce these a lot on my teams and projects but it does help to have these mentioned as a tie breaker when someone feels the need to have such strong consistency. There are other things that I feel much more strongly about and those are covered in the <a href="../tips/main.html">tips chapter</a> (e.g. type assertion is bad, property setters are bad) &#x1F339;.</p>
<p>Key Sections:</p>
<ul>
    <li><a href="#variable-and-function">Variable</a></li>
    <li><a href="#class">Class</a></li>
    <li><a href="#interface">Interface</a></li>
    <li><a href="#type">Type</a></li>
    <li><a href="#namespace">Namespace</a></li>
    <li><a href="#enum">Enum</a></li>
    <li><a href="#null-vs-undefined"><code>null</code> vs. <code>undefined</code></a></li>
    <li><a href="#formatting">Formatting</a></li>
    <li><a href="#quotes">Single vs. Double Quotes</a></li>
    <li><a href="#spaces">Tabs vs. Spaces</a></li>
    <li><a href="#semicolons">Use semicolons</a></li>
    <li><a href="#array">Annotate Arrays as <code>Type[]</code></a></li>
    <li><a href="#filename">File Names</a></li>
    <li><a href="#type-vs-interface"><code>type</code> vs <code>interface</code></a></li>
</ul>
<h2 id="variable-and-function">Variable and Function</h2>
<ul>
    <li>Use <code>camelCase</code> for variable and function names</li>
</ul>
<blockquote>
    <p>Reason: Conventional JavaScript</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> FooVar;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BarFunc</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> fooVar;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">barFunc</span>(<span class="hljs-params"></span>) </span>{ }
</code></pre>
<h2 id="class">Class</h2>
<ul>
    <li>Use <code>PascalCase</code> for class names.</li>
</ul>
<blockquote>
    <p>Reason: This is actually fairly conventional in standard JavaScript.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">class</span> foo { }
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">class</span> Foo { }
</code></pre>
<ul>
    <li>Use <code>camelCase</code> of class members and methods</li>
</ul>
<blockquote>
    <p>Reason: Naturally follows from variable and function naming convention.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">class</span> Foo {
    Bar: <span class="hljs-built_in">number</span>;
    Baz() { }
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">class</span> Foo {
    bar: <span class="hljs-built_in">number</span>;
    baz() { }
}
</code></pre>
<h2 id="interface">Interface</h2>
<ul>
    <li>Use <code>PascalCase</code> for name.</li>
</ul>
<blockquote>
    <p>Reason: Similar to class</p>
</blockquote>
<ul>
    <li>Use <code>camelCase</code> for members.</li>
</ul>
<blockquote>
    <p>Reason: Similar to class</p>
</blockquote>
<ul>
    <li><strong>Don&apos;t</strong> prefix with <code>I</code></li>
</ul>
<blockquote>
    <p>Reason: Unconventional. <code>lib.d.ts</code> defines important interfaces without an <code>I</code> (e.g. Window, Document etc).</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">interface</span> IFoo {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">interface</span> Foo {
}
</code></pre>
<h2 id="type">Type</h2>
<ul>
    <li>Use <code>PascalCase</code> for name.</li>
</ul>
<blockquote>
    <p>Reason: Similar to class</p>
</blockquote>
<ul>
    <li>Use <code>camelCase</code> for members.</li>
</ul>
<blockquote>
    <p>Reason: Similar to class</p>
</blockquote>
<h2 id="namespace">Namespace</h2>
<ul>
    <li>Use <code>PascalCase</code> for names</li>
</ul>
<blockquote>
    <p>Reason: Convention followed by the TypeScript team. Namespaces are effectively just a class with static members. Class names are <code>PascalCase</code> =&gt; Namespace names are <code>PascalCase</code></p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">namespace</span> foo {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">namespace</span> Foo {
}
</code></pre>
<h2 id="enum">Enum</h2>
<ul>
    <li>Use <code>PascalCase</code> for enum names</li>
</ul>
<blockquote>
    <p>Reason: Similar to Class. Is a Type.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">enum</span> color {
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">enum</span> Color {
}
</code></pre>
<ul>
    <li>Use <code>PascalCase</code> for enum member</li>
</ul>
<blockquote>
    <p>Reason: Convention followed by TypeScript team i.e. the language creators e.g <code>SyntaxKind.StringLiteral</code>. Also helps with translation (code generation) of other languages into TypeScript.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">enum</span> Color {
    red
}
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">enum</span> Color {
    Red
}
</code></pre>
<h2 id="null-vs-undefined">Null vs. Undefined</h2>
<ul>
    <li>Prefer not to use either for explicit unavailability</li>
</ul>
<blockquote>
    <p>Reason: these values are commonly used to keep a consistent structure between values. In TypeScript you use <em>types</em> to denote the structure</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">let</span> foo = {x:<span class="hljs-number">123</span>,y:<span class="hljs-literal">undefined</span>};
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">let</span> foo:{x:<span class="hljs-built_in">number</span>,y?:<span class="hljs-built_in">number</span>} = {x:<span class="hljs-number">123</span>};
</code></pre>
<ul>
    <li>Use <code>undefined</code> in general (do consider returning an object like <code>{valid:boolean,value?:Foo}</code> instead)</li>
</ul>
<p><strong><em>Bad</em></strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
</code></pre>
<p><strong><em>Good</em></strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;
</code></pre>
<ul>
    <li>Use <code>null</code> where its a part of the API or conventional</li>
</ul>
<blockquote>
    <p>Reason: It is conventional in Node.js e.g. <code>error</code> is <code>null</code> for NodeBack style callbacks.</p>
</blockquote>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts">cb(<span class="hljs-literal">undefined</span>)
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts">cb(<span class="hljs-literal">null</span>)
</code></pre>
<ul>
    <li>Use <em>truthy</em> check for <strong>objects</strong> being <code>null</code> or <code>undefined</code></li>
</ul>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (error === <span class="hljs-literal">null</span>)
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (error)
</code></pre>
<ul>
    <li>Use <code>== undefined</code> / <code>!= undefined</code> (not <code>===</code> / <code>!==</code>) to check for <code>null</code> / <code>undefined</code> on primitives as it works for both <code>null</code>/<code>undefined</code> but not other falsy values (like <code>&apos;&apos;</code>,<code>0</code>,<code>false</code>) e.g.</li>
</ul>
<p><strong>Bad</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (error !== <span class="hljs-literal">null</span>)
</code></pre>
<p><strong>Good</strong></p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (error != <span class="hljs-literal">undefined</span>)
</code></pre>
<h2 id="formatting">Formatting</h2>
<p>The TypeScript compiler ships with a very nice formatting language service. Whatever output it gives by default is good enough to reduce the cognitive overload on the team.</p>
<p>Use <a href="https://github.com/vvakame/typescript-formatter" target="_blank"><code>tsfmt</code></a> to automatically format your code on the command line. Also your IDE (atom/vscode/vs/sublime) already has formatting support built-in.</p>
<p>Examples:</p>
<pre><code class="lang-ts"><span class="hljs-comment">// Space before type i.e. foo:<space>string</space></span>
<span class="hljs-keyword">const</span> foo: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello&quot;</span>;
</code></pre>
<h2 id="quotes">Quotes</h2>
<ul>
    <li>Prefer single quotes (<code>&apos;</code>) unless escaping.</li>
</ul>
<blockquote>
    <p>Reason: More JavaScript teams do this (e.g. <a href="https://github.com/airbnb/javascript" target="_blank">airbnb</a>, <a href="https://github.com/feross/standard" target="_blank">standard</a>, <a href="https://github.com/npm/npm" target="_blank">npm</a>, <a href="https://github.com/nodejs/node" target="_blank">node</a>, <a href="https://github.com/angular/angular/" target="_blank">google/angular</a>, <a href="https://github.com/facebook/react" target="_blank">facebook/react</a>). Its easier to type (no shift needed on most keyboards). <a href="https://github.com/prettier/prettier/issues/1105" target="_blank">Prettier team recommends single quotes as well</a></p>
    <p>Double quotes are not without merit: Allows easier copy paste of objects into JSON. Allows people to use other languages to work without changing their quote character. Allows you to use apostrophes e.g. <code>He&apos;s not going.</code>. But I&apos;d rather not deviate from where the JS Community is fairly decided.</p>
</blockquote>
<ul>
    <li>When you can&apos;t use double quotes, try using back ticks (`).</li>
</ul>
<blockquote>
    <p>Reason: These generally represent the intent of complex enough strings.</p>
</blockquote>
<h2 id="spaces">Spaces</h2>
<ul>
    <li>Use <code>2</code> spaces. Not tabs.</li>
</ul>
<blockquote>
    <p>Reason: More JavaScript teams do this (e.g. <a href="https://github.com/airbnb/javascript" target="_blank">airbnb</a>, <a href="https://github.com/rwaldron/idiomatic.js" target="_blank">idiomatic</a>, <a href="https://github.com/feross/standard" target="_blank">standard</a>, <a href="https://github.com/npm/npm" target="_blank">npm</a>, <a href="https://github.com/nodejs/node" target="_blank">node</a>, <a href="https://github.com/angular/angular/" target="_blank">google/angular</a>, <a href="https://github.com/facebook/react" target="_blank">facebook/react</a>). The TypeScript/VSCode teams use 4 spaces but are definitely the exception in the ecosystem.</p>
</blockquote>
<h2 id="semicolons">Semicolons</h2>
<ul>
    <li>Use semicolons.</li>
</ul>
<blockquote>
    <p>Reasons: Explicit semicolons helps language formatting tools give consistent results. Missing ASI (automatic semicolon insertion) can trip new devs e.g. <code>foo() \n (function(){})</code> will be a single statement (not two). TC39 <a href="https://github.com/tc39/ecma262/pull/1062" target="_blank">warning on this as well</a>. Example teams: <a href="https://github.com/airbnb/javascript" target="_blank">airbnb</a>, <a href="https://github.com/rwaldron/idiomatic.js" target="_blank">idiomatic</a>, <a href="https://github.com/angular/angular/" target="_blank">google/angular</a>, <a href="https://github.com/facebook/react" target="_blank">facebook/react</a>, <a href="https://github.com/Microsoft/TypeScript/" target="_blank">Microsoft/TypeScript</a>.</p>
</blockquote>
<h2 id="array">Array</h2>
<ul>
    <li>Annotate arrays as <code>foos:Foo[]</code> instead of <code>foos:Array<foo></foo></code>.</li>
</ul>
<blockquote>
    <p>Reasons: Its easier to read. Its used by the TypeScript team. Makes easier to know something is an array as the mind is trained to detect <code>[]</code>.</p>
</blockquote>
<h2 id="filename">Filename</h2>
<p>Name files with <code>camelCase</code>. E.g. <code>accordian.tsx</code>, <code>myControl.tsx</code>, <code>utils.ts</code>, <code>map.ts</code> etc.</p>
<blockquote>
    <p>Reason: Conventional across many JS teams.</p>
</blockquote>
<h2 id="type-vs-interface">type vs. interface</h2>
<ul>
    <li>Use <code>type</code> when you <em>might</em> need a union or intersection:</li>
</ul>
<pre><code>type Foo = number | { someProperty: number }
</code></pre>
<ul>
    <li>Use <code>interface</code> when you want <code>extends</code> or <code>implements</code> e.g</li>
</ul>
<pre><code>interface Foo {
  foo: string;
}
interface FooBar extends Foo {
  bar: string;
}
class X implements FooBar {
  foo: string;
  bar: string;
}
</code></pre>
<ul>
    <li>Otherwise use whatever makes you happy that day.</li>
</ul>
</body>
</html>