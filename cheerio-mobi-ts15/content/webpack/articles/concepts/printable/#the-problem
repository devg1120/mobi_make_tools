<h2 id="the-problem">The Problem<a href="#the-problem" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>So now you have a little bit of insight about how webpack works behind the scenes. &quot;But, how does this affect me?&quot;, you might ask. The simple answer is that most of the time it doesn&apos;t. The runtime will do its thing, utilizing the manifest, and everything will appear to just magically work once your application hits the browser. However, if you decide to improve the performance of your projects by utilizing browser caching, this process will all of a sudden become an important thing to understand.</p>
<p>By using content hashes within your bundle file names, you can indicate to the browser when the content of a file has changed, thus invalidating the cache. Once you start doing this though, you&apos;ll immediately notice some funny behavior. Certain hashes change even when their content apparently does not. This is caused by the injection of the runtime and manifest, which changes every build.</p>
<p>See <a href="/guides/output-management/#the-manifest">the manifest section</a> of our <em>Output management</em> guide to learn how to extract the manifest, and read the guides below to learn more about the intricacies of long term caching.</p>
<h1 id="hot-module-replacement">Hot Module Replacement<a href="#hot-module-replacement" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>Hot Module Replacement (HMR) exchanges, adds, or removes <a href="/concepts/modules/">modules</a> while an application is running, without a full reload. This can significantly speed up development in a few ways:</p>
<ul>
    <li>Retain application state which is lost during a full reload.</li>
    <li>Save valuable development time by only updating what&apos;s changed.</li>
    <li>Instantly update the browser when modifications are made to CSS/JS in the source code, which is almost comparable to changing styles directly in the browser&apos;s dev tools.</li>
</ul>