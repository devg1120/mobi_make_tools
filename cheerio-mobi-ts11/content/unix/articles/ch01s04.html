<div class="sect1" lang="en">
    <div class="titlepage">
        <div>
            <h2 class="title" style="clear: both"><a id="id2808649">What Unix Gets Wrong</a></h2>
        </div>
    </div>
    <p>For a design that dates from 1969, it is remarkably difficult
        to identify design choices in Unix that are unequivocally wrong.
        There are several popular candidates, but each is still a subject of
        spirited debate not merely among Unix fans but across the wider
        community of people who think about and design operating
        systems.</p>
    <p>Unix files have no structure above byte level. File deletion is
        irrevocable. The Unix security model is arguably too primitive. Job
        control is botched. There are too many different kinds of names for
        things. Having a file system at all may have been the wrong choice.
        We will discuss these technical issues in <a href="futurechapter.html" title="Chapter�20.�Futures">Chapter�20</a>.</p>
    <p>But perhaps the most enduring objections to Unix are consequences of
        a feature of its philosophy first made explicit by the designers of
        the X windowing system<a id="id2808686" class="indexterm">. X strives to provide “mechanism,
            not policy”, supporting an extremely general set of graphics
            operations and deferring decisions about toolkits and interface
            look-and-feel (the policy) up to application level. Unix's other
            system-level services display similar tendencies; final choices about
            behavior are pushed as far toward the user as possible. Unix users
            can choose among multiple shells. Unix programs normally provide many
            behavior options and sport elaborate preference�facilities.</a></p>
    <p>This tendency reflects Unix's heritage as an operating system
        designed primarily for technical users, and a consequent belief that
        users know better than operating-system designers what their own needs
        are.</p>
    <div class="blockquote">
        <table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
            <tr>
                <td width="10%" valign="top">�</td>
                <td width="80%" valign="top">
                    <p>This tenet was firmly established at Bell Labs by Dick
                        Hamming<sup>[<a id="id2808745" href="ch01s04.html#ftn.id2808745">5</a>]</sup> who insisted in
                        the 1950s when computers were rare and expensive, that open-shop
                        computing, where customers wrote their own programs, was imperative,
                        because “it is better to solve the right problem the wrong way
                        than the wrong problem the right way”.</p>
                </td>
                <td width="10%" valign="top">�</td>
            </tr>
            <tr>
                <td colspan="2" align="right" valign="top">--<span class="attribution">
                        <span class="author">Doug McIlroy</span>
                        <a id="id2808731" class="indexterm">
                        </a></span></td>
                <td width="10%" valign="top">�</td>
            </tr>
        </table>
    </div>
    <p>But the cost of the mechanism-not-policy approach is that when
        the user <span class="emphasis"><em>can</em></span> set policy, the user
        <span class="emphasis"><em>must</em></span> set policy. Nontechnical end-users
        frequently find Unix's profusion of options and interface styles
        overwhelming and retreat to systems that at least pretend to offer
        them simplicity.</p>
    <p>In the short term, Unix's laissez-faire approach may lose it a
        good many nontechnical users. In the long term, however, it may turn
        out that this ‘mistake’ confers a critical advantage
        — because policy tends to have a short lifetime, mechanism a
        long one. Today's fashion in interface look-and-feel too often becomes
        tomorrow's evolutionary dead end (as people using obsolete X toolkits
        will tell you with some feeling!). So the flip side of the flip side
        is that the “mechanism, not policy” philosophy may enable
        Unix to renew its relevance long after competitors more tied to one
        set of policy or interface choices have faded from
        view.<sup>[<a id="id2808799" href="ch01s04.html#ftn.id2808799">6</a>]</sup></p>
    <div class="footnotes"><br>
        <hr width="100" align="left">
        <div class="footnote">
            <p><sup>[<a id="ftn.id2808745" href="ch01s04.html#id2808745">5</a>] </sup>Yes, the Hamming of ‘Hamming distance’
                and ‘Hamming code’.</p>
        </div>
        <div class="footnote">
            <p><sup>[<a id="ftn.id2808799" href="ch01s04.html#id2808799">6</a>] </sup>Jim Gettys, one of the architects of X (and a
                contributor to this book), has meditated in depth on how X's
                laissez-faire style might be productively carried forward in
                <i>The Two-Edged Sword</i> [<a href="apb.html#Gettys" title="[Gettys]">Gettys</a>]. This essay is well worth reading,
                both for its specific proposals and for its expression of the Unix
                mindset.</p>
        </div>
    </div>
</div>