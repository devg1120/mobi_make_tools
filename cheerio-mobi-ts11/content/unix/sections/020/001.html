
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Unix and Open Source</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/admin/es2015/cheerio-mobi-ts10/undefined" />
  </head>
   <body>
<div class="sect1" lang="en">
    <div class="titlepage">
        <div>
            <h2 class="title" style="clear: both"><a id="id3009499">Unix and Open Source</a></h2>
        </div>
    </div>
    <p>Open-source development exploits the fact that characterizing
        and fixing bugs &#x2014; unlike, say, implementing a particular
        algorithm &#x2014; is a task that lends itself well to being split into
        multiple parallel subtasks. Exploration of the neighborhood of
        possibilities near a prototype design also parallelizes well. With
        the right technological and social machinery in place, development
        teams that are loosely networked and very large can do astoundingly
        good work.</p>
    <p>Astoundingly, that is, if you are carrying around the mental
        habits developed by people who treat process secrecy and proprietary
        control as a given. From <i>The Mythical Man-Month</i>
        [<a href="apb.html#Brooks" title="[Brooks]">Brooks</a>] until the rise of
        Linux</p>
    <p>The early Unix community, before the
        AT&amp;T</p>
    <p>In retrospect, it is rather startling how oblivious we all were
        to the implications of our own behavior. Several people came very
        close to understanding the phenomenon; Richard Gabriel in his
        &#x201C;Worse Is Better&#x201D;</p>
    <p>The rules of open-source development are simple:</p>
    <div class="orderedlist">
        <ol type="1">
            <li>
                <p><span class="emphasis"><em>Let the source be open.</em></span>
                    Have no secrets. Make the code and the process that produces it
                    public. Encourage third-party peer review. Make sure that others
                    can modify and redistribute the code freely. Grow the co-developer
                    community as big as you can.</p>
            </li>
            <li>
                <p><span class="emphasis"><em>Release early, release often.</em></span> A rapid
                    release tempo means quick and effective feedback. When each
                    incremental release is small, changing course in response to
                    real-world feedback is easier.</p>
                <p>Just make sure your first release builds, runs, and demonstrates
                    promise. Usually, an initial version of an open-source program
                    demonstrates promise by doing at least some portion of its final job,
                    sufficient to show that the initiator can actually continue the
                    project. For example, an initial version of a word processor might
                    support typing in text and displaying it on the screen. </p>
                <p>A first release that cannot be compiled or run can kill a
                    project (as, famously, almost happened to the Mozilla browser).
                    Releases that cannot compile suggest that the project developers will
                    be unable to complete the project, Also, non-working programs are
                    difficult for other developers to contribute to, because they cannot
                    easily determine if any change they made improved the program or not.</p>
            </li>
            <li>
                <p><span class="emphasis"><em>Reward contribution with praise.</em></span>
                    If you can&apos;t give your co-developers material rewards,
                    give psychological ones. Even if you can, remember that people will
                    often work harder for reputation than they would for gold.</p>
            </li>
        </ol>
    </div>
    <div class="blockquote">
        <table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote">
            <tr>
                <td width="10%" valign="top">&#xFFFD;</td>
                <td width="80%" valign="top">
                    <p>A corollary of rule 2 is that individual releases should not be
                        momentous events, with many promises attached and much preparation.
                        It&apos;s important to ruthlessly streamline your release process, so that
                        you <span class="emphasis"><em>can</em></span> do frequent releases painlessly. A setup
                        where all other work must stop during release preparation is a
                        terrible mistake. (Notably, if you&apos;re using CVS or something similar,
                        releases in preparation should be branches off the main line of
                        development, so that they don&apos;t block main-line progress.) To sum up,
                        don&apos;t treat releases as big special events; make them part of normal
                        routine.</p>
                </td>
                <td width="10%" valign="top">&#xFFFD;</td>
            </tr>
            <tr>
                <td colspan="2" align="right" valign="top">--<span class="attribution">
                        <span class="author">Henry Spencer</span>
                        </span></td>
                <td width="10%" valign="top">&#xFFFD;</td>
            </tr>
        </table>
    </div>
    <p>Remember that the reason for frequent releases is to shorten and
        speed the feedback loop connecting your user population to your
        developers. Therefore, resist thinking of the next release as a
        polished jewel that cannot ship until everything is perfect. Don&apos;t
        make long wish lists. Make progress incrementally, admit and advertise
        current bugs, and have confidence that perfection will come with
        time. Accept that you will go through dozens of point releases on the
        way, and don&apos;t get upset as the version numbers mount.</p>
    <p>Open-source development uses large teams of programmers
        distributed over the Internet and communicating primarily through
        email and Web documents. Typically, most contributors to any given
        project are volunteers contributing in order to be rewarded by the
        increased usefulness of the software to them, and by reputation
        incentives. A central individual or core group steers the project;
        other contributors may drop in and drop out sporadically. To
        encourage casual contributors, it is important to avoid erecting
        social barriers between them and the core team. Minimize the core
        team&apos;s privileged status, and work hard to keep the boundaries
        inconspicuous.</p>
    <p>Open-source projects follow the Unix-tradition advice of
        automating wherever possible. They use the
        patch(1)
        tool to pass around incremental changes. Many projects (and all large
        ones) have network-accessible code repositories using version-control
        systems like CVS (recall the discussion in <a href="toolschapter.html" title="Chapter&#xFFFD;15.&#xFFFD;Tools">Chapter&#xFFFD;15</a>). Use of automated bug- and patch-tracking
        systems is also common.</p>
    <p>In 1997, almost nobody outside the hacker culture understood
        that it was even possible to run a large project this way, let alone
        get high-quality results. In 2003 this is no longer news;
        projects like Linux</p>
    <p>Abandoning the habit of secrecy in favor of process
        transparency</p>
</div>
</body>
</html>