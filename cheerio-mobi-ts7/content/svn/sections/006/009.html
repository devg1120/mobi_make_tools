
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Vendor Branches</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/gusa1120/es2015/cheerio-mobi-ts7/undefined" />
  </head>
   <body>
    <div class="sect1">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="svn.advanced.vendorbr"></a>Vendor Branches</h2>
          </div>
        </div>
      </div>
      <p>As is especially the case when developing software, the data
      that you maintain under version control is often closely related
      to, or perhaps dependent upon, someone else&apos;s data.  Generally,
      the needs of your project will dictate that you stay as
      up to date as possible with the data provided by that external
      entity without sacrificing the stability of your own project.
      This scenario plays itself out all the time&#x2014;anywhere that
      the information generated by one group of people has a direct
      effect on that which is generated by another group.</p>
      <p>For example, software developers might be working on an
      application that makes use of a third-party library.  Subversion
      has just such a relationship with the Apache Portable Runtime (APR)
      library (see ).
      The Subversion source code depends on the APR library for all
      its portability needs.  In earlier stages of Subversion&apos;s
      development, the project closely tracked APR&apos;s changing API,
      always sticking to the <span class="quote">&#x201C;<span class="quote">bleeding edge</span>&#x201D;</span> of the
      library&apos;s code churn.  Now that both APR and Subversion have
      matured, Subversion attempts to synchronize with APR&apos;s library
      API only at well-tested, stable release points.</p>
      <p>Now, if your project depends on someone else&apos;s information,
      you could attempt to synchronize that information with your own
      in several ways.  Most painfully, you could issue oral or
      written instructions to all the contributors of your project,
      telling them to make sure they have the specific versions
      of that third-party information that your project needs.  If the
      third-party information is maintained in a Subversion
      repository, you could also use Subversion&apos;s externals
      definitions to effectively <span class="quote">&#x201C;<span class="quote">pin down</span>&#x201D;</span> specific
      versions of that information to some location in your own
      working copy (see
      ).</p>
      <p>But sometimes you want to maintain custom modifications to
      third-party code in your own version control system.  Returning
      to the software development example, programmers might need to
      make modifications to that third-party library for their own
      purposes.  These modifications might include new functionality
      or bug fixes, maintained internally only until they become part
      of an official release of the third-party library.  Or the
      changes might never be relayed back to the library maintainers,
      existing solely as custom tweaks to make the library further
      suit the needs of the software developers.</p>
      <p>Now you face an interesting situation.  Your project could
      house its custom modifications to the third-party data in some
      disjointed fashion, such as using patch files or full-fledged
      alternative versions of files and directories.  But these quickly
      become maintenance headaches, requiring some mechanism by which
      to apply your custom changes to the third-party code and
      necessitating regeneration of those changes with each successive
      version of the third-party code that you track.</p>
      <p>The solution to this problem is to use <em class="firstterm">vendor
      branches</em>.  A vendor branch is a directory tree in
      your own version control system that contains information
      provided by a third-party entity, or vendor.  Each version of
      the vendor&apos;s data that you decide to absorb into your project is
      called a <em class="firstterm">vendor drop</em>.</p>
      <p>Vendor branches provide two benefits.  First, by storing
      the currently supported vendor drop in your own version control
      system, you ensure that the members of your project never need to question
      whether they have the right version of the vendor&apos;s data.  They
      simply receive that correct version as part of their regular
      working copy updates.  Second, because the data lives in your
      own Subversion repository, you can store your custom changes to
      it in-place&#x2014;you have no more need of an automated (or
      worse, manual) method for swapping in your customizations.</p>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.advanced.vendorbr.general"></a>General Vendor Branch Management Procedure</h3>
            </div>
          </div>
        </div>
        <p>Managing vendor branches generally works like this: first,
        you create a top-level directory (such as
        <code class="filename">/vendor</code>) to hold the vendor branches.
        Then you import the third-party code into a subdirectory of
        that top-level directory.  You then copy that subdirectory
        into your main development branch (e.g.,
        <code class="filename">/trunk</code>) at the appropriate location.  You
        always make your local changes in the main development branch.
        With each new release of the code you are tracking, you bring
        it into the vendor branch and merge the changes into
        <code class="filename">/trunk</code>, resolving whatever conflicts
        occur between your local changes and the upstream
        changes.</p>
        <p>An example will help to clarify this algorithm.  We&apos;ll use
        a scenario where your development team is creating a
        calculator program that links against a third-party complex
        number arithmetic library, libcomplex.  We&apos;ll begin with the
        initial creation of the vendor branch and the import of the
        first vendor drop.  We&apos;ll call our vendor branch directory
        <code class="filename">libcomplex</code>, and our code drops will go
        into a subdirectory of our vendor branch called
        <code class="filename">current</code>.  And since <span class="command"><strong>svn
        import</strong></span> creates all the intermediate parent
        directories it needs, we can actually accomplish both of these
        steps with a single command:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn import /path/to/libcomplex-1.0 \
             http://svn.example.com/repos/vendor/libcomplex/current \
             -m &quot;importing initial 1.0 vendor drop&quot;
&#x2026;
</pre>
        </div>
        <p>We now have the current version of the libcomplex source
        code in <code class="filename">/vendor/libcomplex/current</code>.  Now,
        we tag that version (see )
        and then copy it into the main development branch.  Our copy
        will create a new directory called
        <code class="filename">libcomplex</code> in our existing
        <code class="filename">calc</code> project directory.  It is in this
        copied version of the vendor data that we will make our
        customizations:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn copy http://svn.example.com/repos/vendor/libcomplex/current  \
           http://svn.example.com/repos/vendor/libcomplex/1.0      \
           -m &quot;tagging libcomplex-1.0&quot;
&#x2026;
$ svn copy http://svn.example.com/repos/vendor/libcomplex/1.0  \
           http://svn.example.com/repos/calc/libcomplex        \
           -m &quot;bringing libcomplex-1.0 into the main branch&quot;
&#x2026;
</pre>
        </div>
        <p>We check out our project&apos;s main branch&#x2014;which now
        includes a copy of the first vendor drop&#x2014;and we get to
        work customizing the libcomplex code.  Before we know it, our
        modified version of libcomplex is now completely integrated
        into our calculator program.<a href="#ftn.idm4798" class="footnote" id="idm4798"><sup class="footnote">[35]</sup></a></p>
        <p>A few weeks later, the developers of libcomplex release a
        new version of their library&#x2014;version 1.1&#x2014;which
        contains some features and functionality that we really want.
        We&apos;d like to upgrade to this new version, but without losing
        the customizations we made to the existing version.  What we
        essentially would like to do is to replace our current
        baseline version of libcomplex 1.0 with a copy of libcomplex
        1.1, and then re-apply the custom modifications we previously
        made to that library to the new version.  But we actually
        approach the problem from the other direction, applying the
        changes made to libcomplex between versions 1.0 and 1.1 to our
        modified copy of it.</p>
        <p>To perform this upgrade, we check out a copy of our vendor
        branch and replace the code in the
        <code class="filename">current</code> directory with the new libcomplex
        1.1 source code.  We quite literally copy new files on top of
        existing files, perhaps exploding the libcomplex 1.1 release
        tarball atop our existing files and directories.  The goal
        here is to make our <code class="filename">current</code> directory
        contain only the libcomplex 1.1 code and to ensure that all
        that code is under version control.  Oh, and we want to do
        this with as little version control history disturbance as
        possible.</p>
        <p>After replacing the 1.0 code with 1.1 code, <span class="command"><strong>svn
        status</strong></span> will show files with local modifications as
        well as, perhaps, some unversioned files.  If we did what we
        were supposed to do, the unversioned files are only those new
        files introduced in the 1.1 release of libcomplex&#x2014;we
        run <span class="command"><strong>svn add</strong></span> on those to get them under
        version control.  If the 1.1 code no longer has certain files
        that were in the 1.0 tree, it may be hard to notice them;
        you&apos;d have to compare the two trees with some external tool
        and then <span class="command"><strong>svn delete</strong></span> any files present in
        1.0 but not in 1.1.  (Although it might also be just fine to
        let these same files live on in unused obscurity!)  Finally,
        once our <code class="filename">current</code> working copy contains
        only the libcomplex 1.1 code, we commit the changes we made to
        get it looking that way.</p>
        <p>Our <code class="filename">current</code> branch now contains the
        new vendor drop.  We tag the new version as 1.1 (in the same
        way we previously tagged the version 1.0 vendor drop), and
        then merge the differences between the tag of the previous
        version and the new current version into our main development
        branch:</p>
        <div class="informalexample">
          <pre class="screen">
$ cd working-copies/calc
$ svn merge ^/vendor/libcomplex/1.0      \
            ^/vendor/libcomplex/current  \
            libcomplex
&#x2026; # resolve all the conflicts between their changes and our changes
$ svn commit -m &quot;merging libcomplex-1.1 into the main branch&quot;
&#x2026;
</pre>
        </div>
        <p>In the trivial use case, the new version of our
        third-party tool would look, from a files-and-directories
        point of view, just like the previous version.  None of the
        libcomplex source files would have been deleted, renamed, or
        moved to different locations&#x2014;the new version would
        contain only textual modifications against the previous one.
        In a perfect world, our modifications would apply cleanly to
        the new version of the library, with absolutely no
        complications or conflicts.</p>
        <p>But things aren&apos;t always that simple, and in fact it is
        quite common for source files to get moved around between
        releases of software.  This complicates the process of
        ensuring that our modifications are still valid for the new
        version of code, and things can quickly degrade into a
        situation where we have to manually re-create our
        customizations in the new version.  Once Subversion knows
        about the history of a given source file&#x2014;including all
        its previous locations&#x2014;the process of merging in the new
        version of the library is pretty simple.  But we are
        responsible for telling Subversion how the source file layout
        changed from vendor drop to vendor drop.</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.advanced.vendorbr.svn_load_dirs"></a>svn_load_dirs.pl</h3>
            </div>
          </div>
        </div>
        <p>Vendor drops that contain more than a few deletes,
        additions, and moves complicate the process of upgrading to
        each successive version of the third-party data.  So
        Subversion supplies the <span class="command"><strong>svn_load_dirs.pl</strong></span>
        script to assist with this process.  This script automates the
        importing steps we mentioned in the general vendor branch
        management procedure to make sure mistakes are minimized.
        You will still be responsible for using the merge commands to
        merge the new versions of the third-party data into your main
        development branch, but <span class="command"><strong>svn_load_dirs.pl</strong></span>
        can help you more quickly and easily arrive at that
        stage.</p>
        <p>In short, <span class="command"><strong>svn_load_dirs.pl</strong></span> is an
        enhancement to <span class="command"><strong>svn import</strong></span> that has several
        important characteristics:</p>
        <div class="itemizedlist">
          <ul class="itemizedlist" style="list-style-type: disc; ">
            <li class="listitem">
              <p>It can be run at any point in time to bring an existing
            directory in the repository to exactly match an external
            directory, performing all the necessary adds and deletes,
            and optionally performing moves, too.</p>
            </li>
            <li class="listitem">
              <p>It takes care of complicated series of operations between
            which Subversion requires an intermediate commit&#x2014;such
            as before renaming a file or directory twice.</p>
            </li>
            <li class="listitem">
              <p>It will optionally tag the newly imported directory.</p>
            </li>
            <li class="listitem">
              <p>It will optionally add arbitrary properties to files and
            directories that match a regular expression.</p>
            </li>
          </ul>
        </div>
        <p><span class="command"><strong>svn_load_dirs.pl</strong></span> takes three mandatory
        arguments.  The first argument is the URL to the base
        Subversion directory to work in.  This argument is followed by
        the URL&#x2014;relative to the first argument&#x2014;into which the
        current vendor drop will be imported.  Finally, the third
        argument is the local directory to import.  Using our previous
        example, a typical run of <span class="command"><strong>svn_load_dirs.pl</strong></span>
        might look like this:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn_load_dirs.pl http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#x2026;
</pre>
        </div>
        <p>You can indicate that you&apos;d like
        <span class="command"><strong>svn_load_dirs.pl</strong></span> to tag the new vendor drop
        by passing the <code class="option">-t</code> command-line option and
        specifying a tag name.  This tag is another URL relative to
        the first program argument.</p>
        <div class="informalexample">
          <pre class="screen">
$ svn_load_dirs.pl -t libcomplex-1.1                              \
                   http://svn.example.com/repos/vendor/libcomplex \
                   current                                        \
                   /path/to/libcomplex-1.1
&#x2026;
</pre>
        </div>
        <p>When you run <span class="command"><strong>svn_load_dirs.pl</strong></span>, it
        examines the contents of your existing <span class="quote">&#x201C;<span class="quote">current</span>&#x201D;</span>
        vendor drop and compares them with the proposed new vendor
        drop.  In the trivial case, no files will be in
        one version and not the other, and the script will perform the
        new import without incident.  If, however, there are
        discrepancies in the file layouts between versions,
        <span class="command"><strong>svn_load_dirs.pl</strong></span> will ask you how
        to resolve those differences.  For example, you
        will have the opportunity to tell the script that you know
        that the file <code class="filename">math.c</code> in version 1.0 of
        libcomplex was renamed to <code class="filename">arithmetic.c</code> in
        libcomplex 1.1.  Any discrepancies not explained by moves
        are treated as regular additions and deletions.</p>
        <p>The script also accepts a separate configuration file for
        setting properties on <span class="emphasis"><em>added</em></span> files and
        directories which match a regular expression.  This configuration
        file is specified to <span class="command"><strong>svn_load_dirs.pl</strong></span> using the
        <code class="option">-p</code> command-line option.  Each line of the
        configuration file is a whitespace-delimited set of two or
        four values: a Perl-style regular expression against which to match the
        added path, a control keyword (either
        <code class="literal">break</code> or <code class="literal">cont</code>), and then
        optionally a property name and value.</p>
        <div class="informalexample">
          <pre class="screen">
\.png$              break   svn:mime-type   image/png
\.jpe?g$            break   svn:mime-type   image/jpeg
\.m3u$              cont    svn:mime-type   audio/x-mpegurl
\.m3u$              break   svn:eol-style   LF
.*                  break   svn:eol-style   native
</pre>
        </div>
        <p>For each added path, the configured property changes whose
        regular expression matches the path are applied in order,
        unless the control specification is <code class="literal">break</code>
        (which means that no more property changes should be applied
        to that path).  If the control specification is
        <code class="literal">cont</code>&#x2014;an abbreviation for
        <code class="literal">continue</code>&#x2014;matching will continue
        with the next line of the configuration file.</p>
        <p>Any whitespace in the regular expression, property name,
        or property value must be surrounded by either single or
        double quotes.  You can escape quotes that
        are not used for wrapping whitespace by preceding them with a
        backslash (<code class="literal">\</code>) character.  The backslash
        escapes only quotes when parsing the configuration file, so do
        not protect any other characters beyond what is necessary for
        the regular expression.</p>
      </div>
      <div class="footnotes">
        <br>
        <hr style="width:100; text-align:left;margin-left: 0">
        <div id="ftn.idm4798" class="footnote">
          <p><a href="#idm4798" class="para"><sup class="para">[35] </sup></a>And is entirely
        bug-free, of course!</p>
        </div>
      </div>
    </div>
</body>
</html>