
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Runtime Debugging</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/gusa1120/es2015/cheerio-mobi-ts9/undefined" />
  </head>
   <body>
<div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="id2989177">Runtime Debugging</a></h2></div></div><p>Anyone who has been programming longer than a week knows that
getting the syntax of your programming language right is the
<span class="emphasis"><em>easy</em></span> part of debugging. The hard part comes after that,
when you need to understand why your syntactically correct program
doesn&apos;t behave as you expect.</p><p>The Unix tradition encourages developers to anticipate this
problem by designing for transparency &#x2014; in particular, designing
programs in such a way that their internal data flows are readily
monitored with the naked eye and simple tools, and readily mentally
modeled</p><p>Design for transparency is not, however, sufficient in itself.
When you are debugging a program at runtime, it&apos;s extremely useful to
be able to examine the state of your program at runtime, set
breakpoints, and execute pieces of it down to the single-statement
level in a controlled way. Unix has a long tradition of hosting
programs to help you with this. Open-source Unixes feature a powerful
one called <i>gdb</i> (yet another
FSF</p><p>Perl</p><p>Remember the Unix philosophy. Spend your time on design quality, not
the low-level details, and automate away everything you can &#x2014;
including the detail work of runtime debugging.</p></div>
</body>
</html>