
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Unix and Object-Oriented Languages</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/gusa1120/es2015/cheerio-mobi-ts9/undefined" />
  </head>
   <body>
<div class="sect1" lang="en"><div class="titlepage"><div><h2 class="title" style="clear: both"><a id="unix_and_oo">Unix and Object-Oriented Languages</a></h2></div></div><p></p><p>Unix programmers tend to share an instinctive sense of these
problems. This tendency appears to be one of the reasons that, under
Unix, OO languages have failed to displace non-OO workhorses like
C</p><p>One reason that OO has succeeded most where it has (GUIs,
simulation, graphics) may be because it&apos;s relatively difficult to get
the ontology of types wrong in those domains.  In GUIs and graphics, for
example, there is generally a rather natural mapping between
manipulable visual objects and classes.  If you find yourself
proliferating classes that have no obvious mapping to what goes
on in the display, it is correspondingly easy to notice that the glue
has gotten too thick.</p><p>One of the central challenges of design in the Unix style is how
to combine the virtue of detachment (simplifying and generalizing
problems from their original context) with the virtue of thin glue and
shallow, flat, transparent hierarchies of code and
design</p><p>We&apos;ll return to some of these points and apply them when we
discuss object-oriented languages in <a href="languageschapter.html" title="Chapter&#xFFFD;14.&#xFFFD;Languages">Chapter&#xFFFD;14</a>.</p></div>
</body>
</html>