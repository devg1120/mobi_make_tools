
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>Basic Merging</title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/tmp/es2015/cheerio-mobi-ts4/css/kindle.css" />
  </head>
   <body>
    <div class="sect1">
      <div class="titlepage">
        <div>
          <div>
            <h2 class="title" style="clear: both"><a id="svn.branchmerge.basicmerging"></a>Basic Merging</h2>
          </div>
        </div>
      </div>
      <p>Now you and Sally are working on parallel branches of the
      project: you&apos;re working on a private branch, and Sally is
      working on the trunk, or main line of development.</p>
      <p>For projects that have a large number of contributors, it&apos;s
      common for most people to have working copies of the trunk.
      Whenever someone needs to make a long-running change that is
      likely to disrupt the trunk, a standard procedure is to create a
      private branch and commit changes there until all the work is
      complete.</p>
      <p>So, the good news is that you and Sally aren&apos;t interfering
      with each other.  The bad news is that it&apos;s very easy to drift
      <span class="emphasis"><em>too</em></span> far apart.  Remember that one of the
      problems with the <span class="quote">&#x201C;<span class="quote">crawl in a hole</span>&#x201D;</span> strategy is
      that by the time you&apos;re finished with your branch, it may be
      near-impossible to merge your changes back into the trunk
      without a huge number of conflicts.</p>
      <p>Instead, you and Sally might continue to share changes as
      you work.  It&apos;s up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively
      <span class="quote">&#x201C;<span class="quote">copy</span>&#x201D;</span> changes between branches.  And when you&apos;re
      completely finished with your branch, your entire set of branch
      changes can be copied back into the trunk.  In Subversion
      terminology, the general act of replicating changes from one
      branch to another is called <em class="firstterm">merging</em>, and
      it is performed using various invocations of the <span class="command"><strong>svn
      merge</strong></span> subcommand.</p>
      <p>In the examples that follow, we&apos;re assuming that both your
      Subversion client and server are running Subversion 1.7 (or
      later).  If either client or server is older than version 1.5,
      things are more complicated: the system won&apos;t track changes
      automatically, forcing you to use painful manual methods to
      achieve similar results.  That is, you&apos;ll always need to use the
      detailed merge syntax to specify specific ranges of revisions to
      replicate (see
       later
      in this chapter), and take special care to keep track of what&apos;s
      already been merged and what hasn&apos;t.  For this reason,
      we <span class="emphasis"><em>strongly</em></span> recommend that you make sure your
      client and server are at least at version 1.5.</p>
      <div class="sidebar">
        <a id="svn.branchmerge.basicmerging.mergetracking"></a>
        <div class="titlepage">
          <div>
            <div>
              <p class="title">
                <strong>Merge Tracking</strong>
              </p>
            </div>
          </div>
        </div>
        <p>
        Subversion 1.5 introduced the
        <em class="firstterm">merge tracking</em> feature to Subversion.
        Prior to this feature keeping track of merges required cumbersome
        manual procedures or the use of external tools. Subsequent
        releases of Subversion introduced many enhancements and bug
        fixes to merge tracking, which is why we recommend using the
        most recent versions on both your server and client.  Keep in
        mind that even if your server is running 1.5 or 1.6, you can still
        use a 1.7 client.  This is particularly important as regards merge
        tracking, because the overwhelming majority of fixes to it are on
        the client side.</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchmerge.changesets"></a>Changesets</h3>
            </div>
          </div>
        </div>
        <p>Before we proceed further, we should warn you that there&apos;s
        a lot of discussion of <span class="quote">&#x201C;<span class="quote">changes</span>&#x201D;</span> in
        the pages ahead.  A lot of people experienced with version
        control systems use the terms <span class="quote">&#x201C;<span class="quote">change</span>&#x201D;</span>
        and <span class="quote">&#x201C;<span class="quote">changeset</span>&#x201D;</span> interchangeably, and we should
        clarify what Subversion understands as
        a <em class="firstterm">changeset</em>.</p>
        <p>Everyone seems to have a slightly different definition
        of changeset, or at least a different
        expectation of what it means for a version control system to
        have one.  For our purposes, let&apos;s say that a changeset is just
        a collection of changes with a unique name.  The changes might
        include textual edits to file contents, modifications to tree
        structure, or tweaks to metadata.  In more common speak, a
        changeset is just a patch with a name you can refer to.</p>
        <p>In Subversion, a global revision
        number <em class="replaceable"><code>N</code></em> names a tree in the
        repository: it&apos;s the way the repository looked after the
        <em class="replaceable"><code>N</code></em>th commit.  It&apos;s also the name of
        an implicit changeset: if you compare
        tree <em class="replaceable"><code>N</code></em> with
        tree <em class="replaceable"><code>N</code></em>-1, you can derive the exact
        patch that was committed.  For this reason, it&apos;s easy to think
        of revision <em class="replaceable"><code>N</code></em> as not just a tree,
        but a changeset as well.  If you use an issue tracker to
        manage bugs, you can use the revision numbers to refer to
        particular patches that fix bugs&#x2014;for example,
        <span class="quote">&#x201C;<span class="quote">this issue was fixed by r9238.</span>&#x201D;</span> Somebody
        can then run <strong class="userinput"><code>svn log -r 9238</code></strong> to read about
        the exact changeset that fixed the bug, and run
        <strong class="userinput"><code>svn diff -c 9238</code></strong> to see the patch itself.
        And (as you&apos;ll see shortly)
        Subversion&apos;s <span class="command"><strong>svn merge</strong></span> command is able to use
        revision numbers.  You can merge specific changesets from one
        branch to another by naming them in the merge
        arguments: passing <strong class="userinput"><code>-c 9238</code></strong>
        to <span class="command"><strong>svn merge</strong></span> would merge changeset r9238
        into your working copy.</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchemerge.basicmerging.stayinsync"></a>Keeping a Branch in Sync</h3>
            </div>
          </div>
        </div>
        <p>Continuing with our running example, let&apos;s suppose that a
        week has passed since you started working on your private
        branch.  Your new feature isn&apos;t finished yet, but at the same
        time you know that other people on your team continue to make
        important changes in the
        project&apos;s <code class="filename">/trunk</code>.  It&apos;s in your best
        interest to replicate those changes to your own branch, just
        to make sure they mesh well with your changes.  This is done
        by performing a <em class="firstterm">sync merge</em>&#x2014;a
        merge operation designed to bring your branch up to date with
        any changes made to its ancestral parent branch since your
        branch was created.</p>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Tip">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Tip]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/tip-grayscale.gif">
              </td>
              <th align="left">Tip</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>Frequently keeping your branch in sync with the main
          development line helps prevent <span class="quote">&#x201C;<span class="quote">surprise</span>&#x201D;</span>
          conflicts when the time comes for you to fold your changes
          back into the trunk.</p>
              </td>
            </tr>
          </table>
        </div>
        <p>Subversion is aware of the history of your branch and
        knows when it split away from the trunk.  To perform a sync
        merge, first make sure your working copy of the branch
        is <span class="quote">&#x201C;<span class="quote">clean</span>&#x201D;</span>&#x2014;that it has no local
        modifications reported by <span class="command"><strong>svn status</strong></span>.  Then
        simply run:</p>
        <div class="informalexample">
          <pre class="screen">
$ pwd
/home/user/my-calc-branch
$ svn merge ^/calc/trunk
--- Merging r345 through r356 into &apos;.&apos;:
U    button.c
U    integer.c
--- Recording mergeinfo for merge of r345 through r356 into &apos;.&apos;:
 U   .
$
</pre>
        </div>
        <p>This basic syntax&#x2014;<strong class="userinput"><code>svn merge
        <em class="replaceable"><code>URL</code></em></code></strong>&#x2014;tells
        Subversion to merge all changes which have not been previously
        merged from the URL to the current working directory (which is
        typically the root of your working copy).  Notice that we&apos;re
        using the caret (<code class="literal">^</code>)
        syntax<a href="#ftn.idm3721" class="footnote" id="idm3721"><sup class="footnote">[26]</sup></a> to avoid having to type out the
        entire <code class="filename">/trunk</code> URL.  Also note
        the <span class="quote">&#x201C;<span class="quote">Recording mergeinfo for merge&#x2026;</span>&#x201D;</span>
        notification.  This tells you that the merge is updating
        the <code class="literal">svn:mergeinfo</code> property. We&apos;ll discuss
        both this property and these notifications later in this
        chapter, in
        .</p>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Tip">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Tip]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/tip-grayscale.gif">
              </td>
              <th align="left">Tip</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>
          In this book and elsewhere (Subversion mailing lists, articles
          on merge tracking, etc.) you will frequently come across the
          term <em class="firstterm">mergeinfo</em>. This is simply shorthand
          for the <code class="literal">svn:mergeinfo</code> property.</p>
              </td>
            </tr>
          </table>
        </div>
        <div class="sidebar">
          <div class="titlepage">
            <div>
              <div>
                <p class="title">
                  <strong>Keeping a Branch in Sync Without Merge Tracking</strong>
                </p>
              </div>
            </div>
          </div>
          <p>You may not always be able to use Subversion&apos;s merge
          tracking feature, perhaps because your server is running
          Subversion 1.4 or earlier.  In such a scenario, you can of
          course still perform merges, but Subversion will need you to
          manually do many of the historical calculations that it
          automatically does on your behalf when the merge tracking
          feature is available.</p>
          <p>To replicate the most recent trunk changes you need to
          perform sync merges the <span class="quote">&#x201C;<span class="quote">old-fashioned</span>&#x201D;</span>
          way&#x2014;by specifying ranges of revisions you wish to
          merge.</p>
          <p>Let&apos;s say you branched <code class="filename">/trunk</code> to 
          <code class="filename">/branches/foo-feature</code> in revision
          400:</p>
          <div class="informalexample">
            <pre class="screen">
$ svn log -v -r 400 ^/branches/foo-feature
------------------------------------------------------------------------
r400 | carol | 2011-11-09 10:51:27 -0500 (Wed, 09 Nov 2011) | 1 line
Changed paths:
A /branch/b2 (from /trunk:399)
Create branch for the foo feature
------------------------------------------------------------------------
</pre>
          </div>
          <p>When you are ready to syncronize your branch with the
          ongoing changes from trunk, you specify the starting
          revision as the revision of <code class="filename">/trunk</code>
          which the branch was copied from and the ending revision as
          <code class="literal">HEAD</code>:</p>
          <div class="informalexample">
            <pre class="screen">
$ svn merge ^/trunk -r399:HEAD
--- Merging r400 through r556 into &apos;.&apos;:
A    include/foo.h
U    src/main.c
A    src/foo.c
&#x2026;
</pre>
          </div>
          <p>After any conflicts have been resolved, you can commit
          the merged changed to your branch.  Now, to avoid
          accidentally trying to merge these same changes into your
          branch again in the future, you&apos;ll need to record the fact
          that you&apos;ve already merged them.  But where should that
          record be kept?  One of the simplest places to record this
          information is in the log message for the commit of the
          merge:</p>
          <div class="informalexample">
            <pre class="screen">
$ svn ci -m &quot;Sync the foo-feature branch with ^/trunk through r556.&quot;
Sending        include/foo.h
&#x2026;
Transmitting file data .
Committed revision 557.
</pre>
          </div>
          <p>The next time you sync
          <code class="filename">/branches/foo-branch</code> with
          <code class="filename">/trunk</code> you repeat this process, except that
          the starting revision is the <span class="emphasis"><em>youngest</em></span>
          revision that&apos;s already been merged in from the trunk.
          If you&apos;ve been keeping good records of your merges in the
          commit log messages, you should be able to determine what
          that youngest revision was by reading the revision logs
          associated with your branch.  Once you know your starting
          revision, you can perform another sync merge:</p>
          <div class="informalexample">
            <pre class="screen">
$ svn merge ^/trunk -r556:HEAD
&#x2026;
</pre>
          </div>
        </div>
        <p>After running the prior example, your branch working copy
        now contains new local modifications, and these edits are
        duplications of all of the changes that have happened on the
        trunk since you first created your branch:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn status
 M      .
M       button.c
M       integer.c
$
</pre>
        </div>
        <p>At this point, the wise thing to do is look at the changes
        carefully with <span class="command"><strong>svn diff</strong></span>, and then build and
        test your branch.  Notice that the current working directory
        (<span class="quote">&#x201C;<span class="quote"><code class="filename">.</code></span>&#x201D;</span>) has also been
        modified; <span class="command"><strong>svn diff</strong></span> will show that
        its <code class="literal">svn:mergeinfo</code> property has been either
        created or modified.  This is important merge-related metadata
        that you should <span class="emphasis"><em>not</em></span> touch, since it is
        needed by future <span class="command"><strong>svn merge</strong></span> commands.
        (We&apos;ll learn more about this metadata later in the
        chapter.)</p>
        <p>After performing the merge, you might also need to resolve
        some conflicts&#x2014;just as you do with <span class="command"><strong>svn
        update</strong></span>&#x2014;or possibly make some small edits to get
        things working properly.  (Remember, just because there are
        no <span class="emphasis"><em>syntactic</em></span> conflicts doesn&apos;t mean there
        aren&apos;t any <span class="emphasis"><em>semantic</em></span> conflicts!)  If you
        encounter serious problems, you can always abort the local
        changes by running <strong class="userinput"><code>svn revert . -R</code></strong> (which
        will undo all local modifications) and starting a
        long <span class="quote">&#x201C;<span class="quote">what&apos;s going on?</span>&#x201D;</span> discussion with your
        collaborators.  If things look good, however, you can
        submit these changes into the repository:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn commit -m &quot;Merged latest trunk changes to my-calc-branch.&quot;
Sending        .
Sending        button.c
Sending        integer.c
Transmitting file data ..
Committed revision 357.
$
</pre>
        </div>
        <p>At this point, your private branch is now <span class="quote">&#x201C;<span class="quote">in
        sync</span>&#x201D;</span> with the trunk, so you can rest easier knowing
        that as you continue to work in isolation, you&apos;re not drifting
        too far away from what everyone else is doing.</p>
        <div class="sidebar">
          <div class="titlepage">
            <div>
              <div>
                <p class="title">
                  <strong>Why Not Use Patches Instead?</strong>
                </p>
              </div>
            </div>
          </div>
          <p>A question may be on your mind, especially if you&apos;re a
          Unix user: why bother to use <span class="command"><strong>svn merge</strong></span> at
          all?  Why not simply use <span class="command"><strong>svn patch</strong></span> or the
          operating system&apos;s <span class="command"><strong>patch</strong></span> command to
          accomplish the same job?  For example:</p>
          <div class="informalexample">
            <pre class="screen">
$ cd my-calc-branch
$ svn diff -r 341:HEAD ^/calc/trunk &gt; my-patch-file
$ svn patch my-patch-file
U         integer.c
$
</pre>
          </div>
          <p>In this particular example, there really isn&apos;t much
          difference.  But <span class="command"><strong>svn merge</strong></span> has special
          abilities that surpass the <span class="command"><strong>patch</strong></span> program.
          The file format used by <span class="command"><strong>patch</strong></span> is quite
          limited; it&apos;s able to tweak file contents only.  There&apos;s no
          way to represent changes to <span class="emphasis"><em>trees</em></span>, such
          as the addition, removal, or renaming of files and
          directories.  Nor can the <span class="command"><strong>patch</strong></span> program
          notice changes to properties.  If Sally&apos;s change had,
          say, added a new directory, the output of <span class="command"><strong>svn
          diff</strong></span> wouldn&apos;t have mentioned it at
          all.  <span class="command"><strong>svn diff</strong></span> outputs only the limited
          patch format, so there are some ideas it simply can&apos;t
          express.  Even Subversion&apos;s own <span class="command"><strong>svn patch</strong></span>
          subcommand, while more flexible than patch program, still has
          similar limitations.</p>
          <p>The <span class="command"><strong>svn merge</strong></span> command, however, can
          express changes in tree structure and properties by directly
          applying them to your working copy.  Even more important,
          this command records the changes that have been duplicated
          to your branch so that Subversion is aware of exactly which
          changes exist in each location (see
          ).
          This is a critical feature that makes branch management
          usable; without it, users would have to manually keep notes
          on which sets of changes have or haven&apos;t been merged
          yet.</p>
        </div>
        <p>Suppose that another week has passed.  You&apos;ve committed
        more changes to your branch, and your comrades have continued
        to improve the trunk as well.  Once again, you want to
        replicate the latest trunk changes to your branch and bring
        yourself in sync.  Just run the same merge command
        again!</p>
        <div class="informalexample">
          <pre class="screen">
$ svn merge ^/calc/trunk
svn: E195020: Cannot merge into mixed-revision working copy [357:378]; try up\
dating first
$
</pre>
        </div>
        <p>Well that was unexpected!  After making changes to your
        branch over the past week you now find yourself with a working
        copy that contains a mixture of revisions (see
        ).  With the
        release of Subversion 1.7 the <span class="command"><strong>svn merge</strong></span>
        subcommand disables merges into mixed-revision working copies
        by default.  Without going into too much detail, this is
        because of limitations in the way merges are tracked by the
        <code class="literal">svn:mergeinfo</code> property (see
         for
        details).  These limitations mean that merges into
        mixed-revision working copies can result in unexpected text
        and tree conflicts.<a href="#ftn.idm3806" class="footnote" id="idm3806"><sup class="footnote">[27]</sup></a>  We don&apos;t want any needless conflicts, so
        we update the working copy and then reattempt the
        merge.</p>
        <div class="informalexample">
          <pre class="screen">
$ svn up
Updating &apos;.&apos;:
At revision 380.
$ svn merge ^/calc/trunk
--- Merging r357 through r380 into &apos;.&apos;:
U    integer.c
U    Makefile
A    README
--- Recording mergeinfo for merge of r357 through r380 into &apos;.&apos;:
 U   .
$
</pre>
        </div>
        <p>Subversion knows which trunk changes you previously
        replicated to your branch, so it carefully replicates only
        those changes you don&apos;t yet have.  And once again, you build,
        test, and <span class="command"><strong>svn commit</strong></span> the local modifications
        to your branch.</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchemerge.basicmerging.stayinsync.subtree"></a>Subtree Merges and Subtree Mergeinfo</h3>
            </div>
          </div>
        </div>
        <p>
        In most of the examples in this chapter the merge target is
        the root directory of a branch (see
        ). While this is a
        best practice, you may occasionally need to merge directly to
        some child of the branch root. This type of merge is called a
        <em class="firstterm">subtree merge</em> and the mergeinfo recorded
        to describe it is called
        <em class="firstterm">subtree mergeinfo</em>. There is nothing
        special about subtree merges or subtree mergeinfo.  In fact
        there is really only one important point to keep in mind
        about these concepts: the complete record of merges to a
        branch may not be contained solely in the mergeinfo on the
        branch root.  You may have to look to any subtree mergeinfo
        to get a full accounting.  Fortunately Subversion does this
        for you and rarely will you need to concern yourself with
        it.  A brief example will help explain:</p>
        <div class="informalexample">
          <pre class="screen">
# We need to merge r958 from trunk to branches/proj-X/doc/INSTALL,
# but that revision also affects main.c, which we don&apos;t want to merge:
$ svn log --verbose --quiet -r 958 ^/
------------------------------------------------------------------------
r958 | bruce | 2011-10-20 13:28:11 -0400 (Thu, 20 Oct 2011)
Changed paths:
   M /trunk/doc/INSTALL
   M /trunk/src/main.c
------------------------------------------------------------------------
# No problem, we&apos;ll do a subtree merge targeting the INSTALL file
# directly, but first take a note of what mergeinfo exists on the
# root of the branch:
$ cd branches/proj-X
$ svn propget svn:mergeinfo --recursive
Properties on &apos;.&apos;:
  svn:mergeinfo
    /trunk:651-652
# Now we perform the subtree merge, note that merge source
# and target both point to INSTALL:
$ svn merge ^/trunk/doc/INSTALL doc/INSTALL -c 958
--- Merging r958 into &apos;doc/INSTALL&apos;:
U    doc/INSTALL
--- Recording mergeinfo for merge of r958 into &apos;doc/INSTALL&apos;:
 G   doc/INSTALL
# Once the merge is complete there is now subtree mergeinfo on INSTALL:
$ svn propget svn:mergeinfo --recursive
Properties on &apos;.&apos;:
  svn:mergeinfo
    /trunk:651-652
Properties on &apos;doc/INSTALL&apos;:
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958
# What if we then decide we do want all of r958? Easy, all we need do is
# repeat the merge of that revision, but this time to the root of the
# branch, Subversion notices the subtree mergeinfo on INSTALL and doesn&apos;t
# try to merge any changes to it, only the changes to main.c are merged:
$ svn merge ^/subversion/trunk . -c 958
--- Merging r958 into &apos;.&apos;:
U    src/main.c
--- Recording mergeinfo for merge of r958 into &apos;.&apos;:
 U   .
--- Eliding mergeinfo from &apos;doc/INSTALL&apos;:
 U   doc/INSTALL
</pre>
        </div>
        <p>You might be wondering why <code class="filename">INSTALL</code>
        in the above example has mergeinfo for r651-652, when we
        only merged r958. This is due to mergeinfo inheritance,
        which we&apos;ll cover in the sidebar
        .  Also note that the subtree mergeinfo on
        <code class="filename">doc/INSTALL</code> was removed, or
        <span class="quote">&#x201C;<span class="quote">elided</span>&#x201D;</span>.  This is called
        <em class="firstterm">mergeinfo elision</em> and it occurs
        whenever Subversion detects redundant subtree mergeinfo.</p>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Tip">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Tip]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/tip-grayscale.gif">
              </td>
              <th align="left">Tip</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>Prior to Subversion 1.7, merges unconditionally updated
          <span class="emphasis"><em>all</em></span> of the subtree mergeinfo under the
          target to describe the merge. For users with a lot of subtree
          mergeinfo this meant that relatively <span class="quote">&#x201C;<span class="quote">simple</span>&#x201D;</span>
          merges (e.g. one which applied a diff to only a single file)
          resulted in changes to every subtree with mergeinfo, even
          those that were not parents of the effected path(s). This
          caused some level of confusion and frustration. Subversion 1.7
          addresses this problem by only updating the mergeinfo on
          subtrees which are parents of the paths modified by the merge
          (i.e. paths changed, added, or deleted by application of the
          difference, see
          ).
          The one exception to this behavior regards the actual merge
          target; the merge target&apos;s mergeinfo is always updated to
          describe the merge, even if the applied difference made no
          changes.</p>
              </td>
            </tr>
          </table>
        </div>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchemerge.basicmerging.reintegrate"></a>Reintegrating a Branch</h3>
            </div>
          </div>
        </div>
        <p>What happens when you finally finish your work, though?
        Your new feature is done, and you&apos;re ready to merge your
        branch changes back to the trunk (so your team can enjoy the
        bounty of your labor).  The process is simple.  First, bring
        your branch into sync with the trunk again, just as you&apos;ve been
        doing all along<a href="#ftn.idm3842" class="footnote" id="idm3842"><sup class="footnote">[28]</sup></a>:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn merge ^/calc/trunk
--- Merging r381 through r385 into &apos;.&apos;:
U    button.c
U    README
--- Recording mergeinfo for merge of r381 through r385 into &apos;.&apos;:
 U   .
$ # build, test, ...
$ svn commit -m &quot;Final merge of trunk changes to my-calc-branch.&quot;
Sending        .
Sending        button.c
Sending        README
Transmitting file data ..
Committed revision 390.
</pre>
        </div>
        <p>Now, use <span class="command"><strong>svn merge</strong></span> with the
        <code class="option">--reintegrate</code> option to replicate your branch
        changes back into the trunk.  You&apos;ll need a working copy
        of <code class="filename">/trunk</code>.  You can get one by doing
        an <span class="command"><strong>svn checkout</strong></span>, dredging up an old trunk
        working copy from somewhere on your disk, or
        using <span class="command"><strong>svn switch</strong></span> (see
        ).  Your trunk
        working copy cannot have any local edits or contain a mixture
        of revisions (see
        ).  While
        these are typically best practices for merging anyway, they
        are <span class="emphasis"><em>required</em></span> when using the
        <code class="option">--reintegrate</code> option.</p>
        <p>Once you have a clean working copy of the trunk, you&apos;re
        ready to merge your branch back into it:</p>
        <div class="informalexample">
          <pre class="screen">
$ pwd
/home/user/calc-trunk
$ svn update  # (make sure the working copy is up to date)
Updating &apos;.&apos;:
At revision 390.
$ svn merge --reintegrate ^/calc/branches/my-calc-branch
--- Merging differences between repository URLs into &apos;.&apos;:
U    button.c
U    integer.c
U    Makefile
--- Recording mergeinfo for merge between repository URLs into &apos;.&apos;:
 U   .
$ # build, test, verify, ...
$ svn commit -m &quot;Merge my-calc-branch back into trunk!&quot;
Sending        .
Sending        button.c
Sending        integer.c
Sending        Makefile
Transmitting file data ..
Committed revision 391.
</pre>
        </div>
        <p>Congratulations, your branch-specific changes have now
        been merged back into the main line of development.  Notice
        our use of the <code class="option">--reintegrate</code> option this time
        around.  The option is critical for reintegrating changes from
        a branch back into its original line of
        development&#x2014;don&apos;t forget it!  It&apos;s needed because this
        sort of <span class="quote">&#x201C;<span class="quote">merge back</span>&#x201D;</span> is a different sort of work
        than what you&apos;ve done up until now.  Previously, we were
        asking <span class="command"><strong>svn merge</strong></span> to grab the <span class="quote">&#x201C;<span class="quote">next
        set</span>&#x201D;</span> of changes from one line of development (the
        trunk) and duplicate them to another (your branch).  This is
        fairly straightforward, and each time Subversion knows how to
        pick up where it left off.  In our prior examples, you can see
        that first it merges the ranges 345:356 from trunk to branch;
        later on, it continues by merging the next contiguously
        available range, 356:380.  When doing the final sync, it
        merges the range 380:385.</p>
        <p>When merging your branch back to the trunk, however, the
        underlying mathematics are quite different.  Your feature
        branch is now a mishmash of both duplicated trunk changes and
        private branch changes, so there&apos;s no simple contiguous range
        of revisions to copy over.  By specifying
        the <code class="option">--reintegrate</code> option, you&apos;re asking
        Subversion to carefully replicate <span class="emphasis"><em>only</em></span>
        those changes unique to your branch.  (And in fact, it does
        this by comparing the latest trunk tree with the latest branch
        tree:  the resulting difference is exactly your branch
        changes!)</p>
        <p>Keep in mind that the <code class="option">--reintegrate</code>
        option is quite specialized in contrast to the more general
        nature of most Subversion subcommand options.  It supports the
        use case described above, but has little applicability outside
        of that.  Because of this narrow focus, in addition to
        requiring an up-to-date working copy<a href="#ftn.idm3870" class="footnote" id="idm3870"><sup class="footnote">[29]</sup></a> with no mixed-revisions,
        it will not function in combination with most of the other
        <span class="command"><strong>svn merge</strong></span> options. You&apos;ll get an error if you
        use any non-global options but these: <code class="option">--accept</code>,
        <code class="option">--dry-run</code>, <code class="option">--diff3-cmd</code>,
        <code class="option">--extensions</code>, or <code class="option">--quiet</code>.</p>
        <p>Now that your private branch is merged to trunk, you may
        wish to remove it from the repository:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn delete ^/calc/branches/my-calc-branch \
             -m &quot;Remove my-calc-branch, reintegrated with trunk in r391.&quot;
Committed revision 392.
</pre>
        </div>
        <p>But wait!  Isn&apos;t the history of that branch valuable?
        What if somebody wants to audit the evolution of your feature
        someday and look at all of your branch changes?  No need to
        worry.  Remember that even though your branch is no longer
        visible in the <code class="filename">/branches</code> directory, its
        existence is still an immutable part of the repository&apos;s
        history.  A simple <span class="command"><strong>svn log</strong></span> command on
        the <code class="filename">/branches</code> URL will show the entire
        history of your branch.  Your branch can even be resurrected
        at some point, should you desire (see
        ).</p>
        <p>Once a <code class="option">--reintegrate</code> merge is done from
        branch to trunk, the branch is no longer usable for further
        work.  It&apos;s not able to correctly absorb new trunk changes,
        nor can it be properly reintegrated to trunk again.  For this
        reason, if you want to keep working on your feature branch, we
        recommend destroying it and then re-creating it from the
        trunk:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn delete http://svn.example.com/repos/calc/branches/my-calc-branch \
             -m &quot;Remove my-calc-branch, reintegrated with trunk in r391.&quot;
Committed revision 392.
$ svn copy http://svn.example.com/repos/calc/trunk \
           http://svn.example.com/repos/calc/branches/my-calc-branch \
           -m &quot;Recreate my-calc-branch from trunk@HEAD.&quot;
Committed revision 393.
</pre>
        </div>
        <p>There is another way of making the branch usable again
        after reintegration, without deleting the branch. See
        .</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchmerge.basicmerging.mergeinfo"></a>Mergeinfo and Previews</h3>
            </div>
          </div>
        </div>
        <p>
        The basic mechanism Subversion uses to track
        changesets&#x2014;that is, which changes have been merged to
        which branches&#x2014;is by recording data in versioned
        properties.  Specifically, merge data is tracked in
        the <code class="literal">svn:mergeinfo</code> property attached to
        files and directories.  (If you&apos;re not familiar with
        Subversion properties, see .)</p>
        <p>You can examine the property, just like any other:</p>
        <div class="informalexample">
          <pre class="screen">
$ cd my-calc-branch
$ svn propget svn:mergeinfo .
/trunk:341-390
$
</pre>
        </div>
        <div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Warning">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Warning]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/warning-grayscale.gif">
              </td>
              <th align="left">Warning</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>While it is possible to
          modify <code class="literal">svn:mergeinfo</code> just as you might
          any other versioned property, we strongly discourage doing
          so unless you <span class="emphasis"><em>really</em></span> know what you&apos;re
          doing.</p>
              </td>
            </tr>
          </table>
        </div>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Tip">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Tip]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/tip-grayscale.gif">
              </td>
              <th align="left">Tip</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>The amount of <code class="literal">svn:mergeinfo</code> on a single
          path can get quite large, as can the output of a
          <span class="command"><strong>svn propget --recursive</strong></span> or
          <span class="command"><strong>svn proplist --recursive</strong></span> when dealing with
          large amounts of subtree mergeinfo, see
          . The formatted output produced by the
          <code class="option">--verbose</code> option with either of these
          subcommands is often very helpful in these cases.</p>
              </td>
            </tr>
          </table>
        </div>
        <p>The <code class="literal">svn:mergeinfo</code> property is
        automatically maintained by Subversion whenever you
        run <span class="command"><strong>svn merge</strong></span>.  Its value indicates which
        changes made to a given path have been replicated into the
        directory in question.  In our previous example, the path
        which is the source of the merged changes is
        <code class="filename">/trunk</code> and the directory which has
        received the changes is
        <code class="filename">/branches/my-calc-branch</code>.
        Earlier versions of Subversion maintained the
        <code class="literal">svn:mergeinfo</code> property silently. You could
        still detect the changes, after a merge completed, with the
        <span class="command"><strong>svn diff</strong></span> or <span class="command"><strong>svn status</strong></span>
        subcommands, but the merge itself gave no indication when it
        changed the <code class="literal">svn:mergeinfo</code> property. This is no
        longer true in Subversion 1.7, which has several new notifications
        to alert you when a merge updates the
        <code class="literal">svn:mergeinfo</code> property. These notifications
        all begin with <span class="quote">&#x201C;<span class="quote">--- Recording mergeinfo for</span>&#x201D;</span>
        and appear at the end of the merge.  Unlike other merge
        notifications, these don&apos;t describe the application of a
        difference to a working copy
        (see ),
        but instead describe &quot;housekeeping&quot; changes made to keep
        track of what was merged.</p>
        <p>Subversion also provides a subcommand, <span class="command"><strong>svn
        mergeinfo</strong></span>, which is helpful in seeing not only
        which changesets a directory has absorbed, but also which
        changesets it&apos;s still eligible to receive.  This gives a sort
        of preview of which changes a subsequent <span class="command"><strong>svn
        merge</strong></span> operation would replicate to your
        branch.</p>
        <div class="informalexample">
          <pre class="screen">
$ cd my-calc-branch
# Which changes have already been merged from trunk to branch?
$ svn mergeinfo ^/calc/trunk
r341
r342
r343
&#x2026;
r388
r389
r390
# Which changes are still eligible to merge from trunk to branch?
$ svn mergeinfo ^/calc/trunk --show-revs eligible
r391
r392
r393
r394
r395
$
</pre>
        </div>
        <p>The <span class="command"><strong>svn mergeinfo</strong></span> command requires
        a <span class="quote">&#x201C;<span class="quote">source</span>&#x201D;</span> URL (where the changes come
        from), and takes an optional <span class="quote">&#x201C;<span class="quote">target</span>&#x201D;</span> URL (where
        the changes merge to).  If no target URL is given,
        it assumes that the current working directory is the
        target.  In the prior example, because we&apos;re querying our
        branch working copy, the command assumes we&apos;re interested in
        receiving changes to <code class="filename">/branches/mybranch</code>
        from the specified trunk URL.</p>
        <div class="sidebar">
          <a id="svn.branchmerge.basicmerging.mergeinfo.inheritance"></a>
          <div class="titlepage">
            <div>
              <div>
                <p class="title">
                  <strong>Mergeinfo Inheritance</strong>
                </p>
              </div>
            </div>
          </div>
          <p>When a path has the <code class="literal">svn:mergeinfo</code>
          property set on it we say it has <em class="firstterm">explicit
          mergeinfo</em>.  This explicit mergeinfo describes
          not only what changes were merged into that particular
          directory, but also all the children of that directory
          (because those children inherit the mergeinfo of their
          parent path).  For example:</p>
          <div class="informalexample">
            <pre class="screen">
# What explicit mergeinfo exists on a branch?
$ svn propget svn:mergeinfo ^/branches/proj-X --recursive
/trunk:651-652
# What children does proj-X have?
$ svn list --recursive ^/branches/proj-X
doc/
doc/INSTALL
README
src/main.c
# Ask what revs were merged to a file with no explicit mergeinfo
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c
651
652
</pre>
          </div>
          <p>Notice from our first subcommand that only the root of
          <code class="filename">/branches/proj-X</code> has any explicit
          mergeinfo.  However, when we use
          <span class="command"><strong>svn mergeinfo</strong></span> to ask what was merged to
          <code class="filename">/branches/proj-X/src/main.c</code> it reports
          that the two revisions described in the explicit mergeinfo
          on <code class="filename">/branches/proj-X</code> were merged.  This is
          because <code class="filename">/branches/proj-X/src/main.c</code>, having
          no explicit mergeinfo of its own, inherits the mergeinfo from
          its nearest parent with explicit mergeinfo,
          <code class="filename">/branches/proj-X</code>.</p>
          <p>There are two cases in which mergeinfo is not inherited.
          First, if a path has explicit mergeinfo, then it never inherits
          mergeinfo. Another way to think of this is that explicit
          mergeinfo is always a complete record of the merges to a given
          path, once it exists it overrides any mergeinfo that path might
          otherwise inherit. The second way is when dealing with
          non-inheritable mergeinfo, a special type of explicit mergeinfo
          that applies <span class="emphasis"><em>only</em></span> to the directory on which
          the <code class="literal">svn:mergeinfo</code> property is set (and it&apos;s
          only directories, non-inheritable mergeinfo is never set on
          files). For example:</p>
          <div class="informalexample">
            <pre class="screen">
# The &apos;*&apos; decorator indicates non-inheritable mergeinfo
$ svn propget svn:mergeinfo ^/branches/proj-X
/trunk:651-652,758*
# Revision 758 is non-inheritable, but still applies to the path it is
# set on. Here the &apos;*&apos; decorator signals that r758 is only partially
# merged from trunk. 
$ svn mergeinfo ^/trunk ^/branches/proj-X
651
652
758*
# Revision 758 is not reported as merged because it is non-inheritable
# and applies only to ^/trunk
$ svn mergeinfo ^/trunk/src/main.c ^/branches/proj-X/src/main.c
651
652
</pre>
          </div>
          <p>You might never have to think about mergeinfo inheritance
          or encounter non-inheritable mergeinfo in your own repository.
          A discussion of the full ramifications of mergeinfo inheritance
          are beyond the scope of this book.  If you have more questions
          check out some of the references mentioned in
          </p>
        </div>
        <p>With the release of Subversion 1.7, the
        <span class="command"><strong>svn mergeinfo</strong></span> subcommand can also account for
        subtree mergeinfo and non-inheritable mergeinfo.  It accounts for
        subtree mergeinfo by use of the <code class="option">--recursive</code> or
        <code class="option">--depth</code> options, while non-inheritable mergeinfo
        is considered by default.</p>
        <p>Let&apos;s say we have a branch with both subtree and
        non-inheritable mergeinfo:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn propget svn:mergeinfo --recursive -v
# Non-inheritable mergeinfo
Properties on &apos;.&apos;:
  svn:mergeinfo
    /trunk:651-652,758*
# Subtree mergeinfo
Properties on &apos;doc/INSTALL&apos;:
  svn:mergeinfo
    /trunk/doc/INSTALL:651-652,958,1060
</pre>
        </div>
        <p>From the above mergeinfo we see that r758 has only been
        merged into the root of the branch, but not any of the root&apos;s
        children.  We also see that both r958 and r1060 have been
        merged only to the <code class="filename">doc/INSTALL</code> file.
        When we use <span class="command"><strong>svn mergeinfo</strong></span> with the
        <code class="option">--recursive</code> option to see what has been merged
        from <code class="filename">^/trunk</code> to this branch, we see two
        revisions are flagged with the <code class="literal">*</code> marker:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn mergeinfo --show-revs=merged ^/trunk . --recursive
651
652
758*
958*
1060
</pre>
        </div>
        <p>The <code class="literal">*</code> indicates revisions that are only
        <span class="emphasis"><em>partially</em></span> merged to the target in question
        (the meaning is the same if we are checking for eligible
        revisions).  What this means in this example is that if we tried
        to merge r758 or r958 from <code class="filename">^/trunk</code> then more
        changes would result. Likewise, because r1060 is
        <span class="emphasis"><em>not</em></span> flagged with a <code class="literal">*</code>,
        we know that it only affects <code class="filename">doc/INSTALL</code>
        and that trying to merge it would have no result.<a href="#ftn.idm3984" class="footnote" id="idm3984"><sup class="footnote">[30]</sup></a></p>
        <p>Another way to get a more precise preview of a merge
        operation is to use the <code class="option">--dry-run</code>
        option:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn merge ^/calc/trunk --dry-run
--- Merging r391 through r395 into &apos;branch&apos;:
U    integer.c
$ svn status
#  nothing printed, working copy is still unchanged.
</pre>
        </div>
        <p>The <code class="option">--dry-run</code> option doesn&apos;t actually
        apply any local changes to the working copy.  It shows only
        status codes that <span class="emphasis"><em>would</em></span> be printed in a
        real merge.  It&apos;s useful for getting a <span class="quote">&#x201C;<span class="quote">high-level</span>&#x201D;</span>
        preview of the potential merge, for those times
        when running <span class="command"><strong>svn diff</strong></span> gives too much
        detail.</p>
        <div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
          <table border="0" summary="Tip">
            <tr>
              <td rowspan="2" align="center" valign="top" width="25">
                <img alt="[Tip]" src="/tmp/es2015/cheerio-mobi-ts4/content/svn/processed_images/tip-grayscale.gif">
              </td>
              <th align="left">Tip</th>
            </tr>
            <tr>
              <td align="left" valign="top">
                <p>After performing a merge operation, but before
          committing the results of the merge, you can
          use <strong class="userinput"><code>svn diff
          --depth=empty <em class="replaceable"><code>/path/to/merge/target</code></em></code></strong>
          to see only the changes to the immediate target of your
          merge.  If your merge target was a directory, only property
          differences are displayed.  This is a handy way to see
          the changes to the
          <code class="literal">svn:mergeinfo</code> property recorded by the
          merge operation, which will remind you about what you&apos;ve
          just merged.</p>
              </td>
            </tr>
          </table>
        </div>
        <p>Of course, the best way to preview a merge operation is to
        just do it!  Remember, running <span class="command"><strong>svn merge</strong></span>
        isn&apos;t an inherently risky thing (unless you&apos;ve made local
        modifications to your working copy&#x2014;but we already
        stressed that you shouldn&apos;t merge into such an
        environment).  If you don&apos;t like the results of the merge,
        simply run <strong class="userinput"><code>svn revert . -R</code></strong> to revert
        the changes from your working copy and retry the command with
        different options.  The merge isn&apos;t final until you
        actually <span class="command"><strong>svn commit</strong></span> the results.</p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchmerge.basicmerging.undo"></a>Undoing Changes</h3>
            </div>
          </div>
        </div>
        <p>An extremely common use for <span class="command"><strong>svn merge</strong></span>
        is to roll back a change that has already been committed.
        Suppose you&apos;re working away happily on a working copy of
        <code class="filename">/calc/trunk</code>, and you discover that the
        change made way back in revision 303, which changed
        <code class="filename">integer.c</code>, is completely wrong.  It never
        should have been committed.  You can use <span class="command"><strong>svn
        merge</strong></span> to <span class="quote">&#x201C;<span class="quote">undo</span>&#x201D;</span> the change in your
        working copy, and then commit the local modification to the
        repository.  All you need to do is to specify a
        <span class="emphasis"><em>reverse</em></span> difference.  (You can do this by
        specifying <code class="option">--revision 303:302</code>, or by an
        equivalent <code class="option">--change -303</code>.)</p>
        <div class="informalexample">
          <pre class="screen">
$ svn merge -c -303 ^/calc/trunk
--- Reverse-merging r303 into &apos;integer.c&apos;:
U    integer.c
--- Recording mergeinfo for reverse merge of r303 into &apos;integer.c&apos;:
 U   A-branch
$ svn status
 M      .
M       integer.c
$ svn diff
&#x2026;
# verify that the change is removed
&#x2026;
$ svn commit -m &quot;Undoing change committed in r303.&quot;
Sending        integer.c
Transmitting file data .
Committed revision 350.
</pre>
        </div>
        <p>As we mentioned earlier, one way to think about a
        repository revision is as a specific changeset.  By using the
        <code class="option">-r</code> option, you can ask <span class="command"><strong>svn
        merge</strong></span> to apply a changeset, or a whole range of
        changesets, to your working copy.  In our case of undoing a
        change, we&apos;re asking <span class="command"><strong>svn merge</strong></span> to apply
        changeset r303 to our working copy
        <span class="emphasis"><em>backward</em></span>.</p>
        <p>Keep in mind that rolling back a change like this is just
        like any other <span class="command"><strong>svn merge</strong></span> operation, so you
        should use <span class="command"><strong>svn status</strong></span> and <span class="command"><strong>svn
        diff</strong></span> to confirm that your work is in the state you
        want it to be in, and then use <span class="command"><strong>svn commit</strong></span>
        to send the final version to the repository.  After
        committing, this particular changeset is no longer reflected
        in the <code class="literal">HEAD</code> revision.</p>
        <p>Again, you may be thinking: well, that really didn&apos;t undo
        the commit, did it?  The change still exists in revision 303.
        If somebody checks out a version of the
        <code class="filename">calc</code> project between revisions 303 and
        349, she&apos;ll still see the bad change, right?</p>
        <p>Yes, that&apos;s true.  When we talk about
        <span class="quote">&#x201C;<span class="quote">removing</span>&#x201D;</span> a change, we&apos;re really talking about
        removing it from the <code class="literal">HEAD</code> revision.  The
        original change still exists in the repository&apos;s history.  For
        most situations, this is good enough.  Most people are only
        interested in tracking the <code class="literal">HEAD</code> of a
        project anyway.  There are special cases, however, where you
        really might want to destroy all evidence of the commit.
        (Perhaps somebody accidentally committed a confidential
        document.)  This isn&apos;t so easy, it turns out, because
        Subversion was deliberately designed to never lose
        information.  Revisions are immutable trees that build upon
        one another.  Removing a revision from history would cause a
        domino effect, creating chaos in all subsequent revisions and
        possibly invalidating all working copies.<a href="#ftn.idm4035" class="footnote" id="idm4035"><sup class="footnote">[31]</sup></a></p>
      </div>
      <div class="sect2">
        <div class="titlepage">
          <div>
            <div>
              <h3 class="title"><a id="svn.branchmerge.basicmerging.resurrect"></a>Resurrecting Deleted Items</h3>
            </div>
          </div>
        </div>
        <p>The great thing about version control systems is that
        information is never lost.  Even when you delete a file or
        directory, it may be gone from the <code class="literal">HEAD</code>
        revision, but the object still exists in earlier revisions.
        One of the most common questions new users ask is, <span class="quote">&#x201C;<span class="quote">How
        do I get my old file or directory back?</span>&#x201D;</span></p>
        <p>The first step is to define
        exactly <span class="emphasis"><em>which</em></span> item you&apos;re
        trying to resurrect.  Here&apos;s a useful metaphor: you can think
        of every object in the repository as existing in a sort of
        two-dimensional coordinate system.  The first coordinate is a
        particular revision tree, and the second coordinate is a path
        within that tree.  So every version of your file or directory
        is defined by a specific coordinate pair.  (Remember the
        <span class="quote">&#x201C;<span class="quote">peg revision</span>&#x201D;</span>
        syntax&#x2014;foo.c@224&#x2014;mentioned back in
        .)</p>
        <p>First, you might need to use <span class="command"><strong>svn log</strong></span> to
        discover the exact coordinate pair you wish to resurrect.  A
        good strategy is to run <strong class="userinput"><code>svn log --verbose</code></strong>
        in a directory that used to contain your deleted item.  The
        <code class="option">--verbose</code> (<code class="option">-v</code>) option shows
        a list of all changed items in each revision; all you need to
        do is find the revision in which you deleted the file or
        directory.  You can do this visually, or by using another tool
        to examine the log output (via <span class="command"><strong>grep</strong></span>, or
        perhaps via an incremental search in an editor).</p>
        <div class="informalexample">
          <pre class="screen">
$ cd parent-dir
$ svn log -v
&#x2026;
------------------------------------------------------------------------
r808 | joe | 2003-12-26 14:29:40 -0600 (Fri, 26 Dec 2003) | 3 lines
Changed paths:
   D /calc/trunk/real.c
   M /calc/trunk/integer.c
Added fast fourier transform functions to integer.c.
Removed real.c because code now in double.c.
&#x2026;
</pre>
        </div>
        <p>In the example, we&apos;re assuming that you&apos;re looking for a
        deleted file <code class="filename">real.c</code>.  By looking through
        the logs of a parent directory, you&apos;ve spotted that this file
        was deleted in revision 808.  Therefore, the last version of
        the file to exist was in the revision right before that.
        Conclusion: you want to resurrect the path
        <code class="filename">/calc/trunk/real.c</code> from revision
        807.</p>
        <p>That was the hard part&#x2014;the research.  Now that you
        know what you want to restore, you have two different
        choices.</p>
        <p>One option is to use <span class="command"><strong>svn merge</strong></span> to apply
        revision 808 <span class="quote">&#x201C;<span class="quote">in reverse.</span>&#x201D;</span> (We already
        discussed how to undo changes in
        .)  This
        would have the effect of re-adding <code class="filename">real.c</code>
        as a local modification.  The file would be scheduled for
        addition, and after a commit, the file would again exist
        in <code class="literal">HEAD</code>.</p>
        <p>In this particular example, however, this is probably not
        the best strategy.  Reverse-applying revision 808 would not
        only schedule <code class="filename">real.c</code> for addition, but
        the log message indicates that it would also undo certain
        changes to <code class="filename">integer.c</code>, which you don&apos;t
        want.  Certainly, you could reverse-merge revision 808 and
        then <span class="command"><strong>svn revert</strong></span> the local modifications to
        <code class="filename">integer.c</code>, but this technique doesn&apos;t
        scale well.  What if 90 files were changed in revision
        808?</p>
        <p>A second, more targeted strategy is not to use
        <span class="command"><strong>svn merge</strong></span> at all, but rather to use the
        <span class="command"><strong>svn copy</strong></span> command.  Simply copy the exact
        revision and path <span class="quote">&#x201C;<span class="quote">coordinate pair</span>&#x201D;</span> from the
        repository to your working copy:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn copy ^/calc/trunk/real.c@807 ./real.c
$ svn status
A  +    real.c
$ svn commit -m &quot;Resurrected real.c from revision 807, /calc/trunk/real.c.&quot;
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre>
        </div>
        <p>The plus sign in the status output indicates that the item
        isn&apos;t merely scheduled for addition, but scheduled for
        addition <span class="quote">&#x201C;<span class="quote">with history.</span>&#x201D;</span>  Subversion remembers
        where it was copied from.  In the future, running <span class="command"><strong>svn
        log</strong></span> on this file will traverse back through the
        file&apos;s resurrection and through all the history it had prior
        to revision 807.  In other words, this new
        <code class="filename">real.c</code> isn&apos;t really new; it&apos;s a direct
        descendant of the original, deleted file.  This is usually
        considered a good and useful thing.  If, however, you wanted
        to resurrect the file <span class="emphasis"><em>without</em></span>
        maintaining a historical link to the old file, this technique
        works just as well:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn cat ^/calc/trunk/real.c@807 &gt; ./real.c
$ svn add real.c
A         real.c
$ svn commit -m &quot;Re-created real.c from revision 807.&quot;
Adding         real.c
Transmitting file data .
Committed revision 1390.
</pre>
        </div>
        <p>Although our example shows us resurrecting a file, note
        that these same techniques work just as well for resurrecting
        deleted directories.  Also note that a resurrection doesn&apos;t
        have to happen in your working copy&#x2014;it can happen
        entirely in the repository:</p>
        <div class="informalexample">
          <pre class="screen">
$ svn copy ^/calc/trunk/real.c@807 ^/calc/trunk/ \
           -m &quot;Resurrect real.c from revision 807.&quot;
Committed revision 1390.
$ svn update
Updating &apos;.&apos;:
A    real.c
Updated to revision 1390.
</pre>
        </div>
      </div>
      <div class="footnotes">
        <br>
        <hr style="width:100; text-align:left;margin-left: 0">
        <div id="ftn.idm3721" class="footnote">
          <p><a href="#idm3721" class="para"><sup class="para">[26] </sup></a>This was introduced in svn
        1.6.</p>
        </div>
        <div id="ftn.idm3806" class="footnote">
          <p><a href="#idm3806" class="para"><sup class="para">[27] </sup></a>The <span class="command"><strong>svn
        merge</strong></span> subcommand
        option <code class="option">--allow-mixed-revisions</code> allows you to
        override this prohibition, but you should only do so if you
        understand the ramifications and have a good reason for
        it.</p>
        </div>
        <div id="ftn.idm3842" class="footnote">
          <p><a href="#idm3842" class="para"><sup class="para">[28] </sup></a>With Subversion 1.7 you don&apos;t
        absolutely have to do all your sync merges to the root of your
        branch as we do in this example.  <span class="emphasis"><em>If</em></span> your
        branch is effectively synced via a series of subtree
        merges then the reintegrate will work, but ask yourself, if the
        branch is effectively synced, then why are you doing subtree
        merges? Doing so is almost always needlessly
        complex.</p>
        </div>
        <div id="ftn.idm3870" class="footnote">
          <p><a href="#idm3870" class="para"><sup class="para">[29] </sup></a>Reintegrate
        merges are allowed if the target is a shallow checkout (see
        ) but any paths affected
        by the diff which are <span class="quote">&#x201C;<span class="quote">missing</span>&#x201D;</span> due to the sparse
        working copy will be skipped, probably <span class="emphasis"><em>not</em></span>
        what you intended!</p>
        </div>
        <div id="ftn.idm3984" class="footnote">
          <p><a href="#idm3984" class="para"><sup class="para">[30] </sup></a>
        This is often termed an <span class="quote">&#x201C;<span class="quote">inoperative</span>&#x201D;</span> merge.  Though
        in this example the merge of r1060 would do something: It would
        update the mergeinfo on the root of the branch, but it would be
        inoperative in the sense that no diff would be
        applied.</p>
        </div>
        <div id="ftn.idm4035" class="footnote">
          <p><a href="#idm4035" class="para"><sup class="para">[31] </sup></a>The
        Subversion project has plans, however, to someday implement a
        command that would accomplish the task of permanently deleting
        information.  In the meantime, see
         for a
        possible workaround.</p>
        </div>
      </div>
    </div>
</body>
</html>