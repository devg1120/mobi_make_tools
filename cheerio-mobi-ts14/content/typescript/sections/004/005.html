
 <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Cont
ent-Type" />
    <title>
                    let
                </title>
    <meta name="description" content="undefined" />
    <meta name="author" content="undefined" />
    <link rel="stylesheet" type="text/css" href="/home/admin/es2015/cheerio-mobi-ts14/undefined" />
  </head>
   <body>
<h3 id="let">let</h3>
<p><code>var</code> Variables in JavaScript are <em>function scoped</em>. This is different from many other languages (C# / Java etc.) where the variables are <em>block scoped</em>. If you bring a <em>block scoped</em> mindset to JavaScript, you would expect the following to print <code>123</code>, instead it will print <code>456</code>:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">123</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">456</span>;
}
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 456</span>
</code></pre>
<p>This is because <code>{</code> does not create a new <em>variable scope</em>. The variable <code>foo</code> is the same inside the if <em>block</em> as it is outside the if block. This is a common source of errors in JavaScript programming. This is why TypeScript (and ES6) introduces the <code>let</code> keyword to allow you to define variables with true <em>block scope</em>. That is if you use <code>let</code> instead of <code>var</code> you get a true unique element disconnected from what you might have defined outside the scope. The same example is demonstrated with <code>let</code>:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">let</span> foo = <span class="hljs-number">123</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">456</span>;
}
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 123</span>
</code></pre>
<p>Another place where <code>let</code> would save you from errors is loops.</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; array.length; index++) {
    <span class="hljs-built_in">console</span>.log(array[index]);
}
<span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 0</span>
</code></pre>
<p>In all sincerity we find it better to use <code>let</code> whenever possible as it leads to lesser surprises for new and existing multi-lingual developers.</p>
<h4 id="functions-create-a-new-scope">Functions create a new scope</h4>
<p>Since we mentioned it, we&apos;d like to demonstrate that functions create a new variable scope in JavaScript. Consider the following:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> foo = <span class="hljs-number">123</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">456</span>;
}
test();
<span class="hljs-built_in">console</span>.log(foo); <span class="hljs-comment">// 123</span>
</code></pre>
<p>This behaves as you would expect. Without this it would be very difficult to write code in JavaScript.</p>
<h4 id="generated-js">Generated JS</h4>
<p>The JS generated by TypeScript is simple renaming of the <code>let</code> variable if a similar name already exists in the surrounding scope. E.g. the following is generated as is with a simple replacement of <code>var</code> with <code>let</code>:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">123</span>;
}
<span class="hljs-comment">// becomes //</span>
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> foo = <span class="hljs-number">123</span>;
}
</code></pre>
<p>However, if the variable name is already taken by the surrounding scope then a new variable name is generated as shown (notice <code>foo_1</code>):</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&apos;123&apos;</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">let</span> foo = <span class="hljs-number">123</span>;
}
<span class="hljs-comment">// becomes //</span>
<span class="hljs-keyword">var</span> foo = <span class="hljs-string">&apos;123&apos;</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) {
    <span class="hljs-keyword">var</span> foo_1 = <span class="hljs-number">123</span>; <span class="hljs-comment">// Renamed</span>
}
</code></pre>
<h4 id="switch">Switch</h4>
<p>You can wrap your <code>case</code> bodies in <code>{}</code> to reuse variable names reliably in different <code>case</code> statement as shown below:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">switch</span> (name) {
    <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;x&apos;</span>: {
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-keyword">case</span> <span class="hljs-string">&apos;y&apos;</span>: {
        <span class="hljs-keyword">let</span> x = <span class="hljs-number">10</span>;
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">break</span>;
    }
}
</code></pre>
<h4 id="let-in-closures">let in closures</h4>
<p>A common programming interview question for a JavaScript developer is what is the log of this simple file:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> funcs = [];
<span class="hljs-comment">// create a bunch of functions</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    funcs.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(i);
    })
}
<span class="hljs-comment">// call them</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {
    funcs[j]();
}
</code></pre>
<p>One would have expected it to be <code>0,1,2</code>. Surprisingly it is going to be <code>3</code> for all three functions. Reason is that all three functions are using the variable <code>i</code> from the outer scope and at the time we execute them (in the second loop) the value of <code>i</code> will be <code>3</code> (that&apos;s the termination condition for the first loop).</p>
<p>A fix would be to create a new variable in each loop specific to that loop iteration. As we&apos;ve learnt before we can create a new variable scope by creating a new function and immediately executing it (i.e. the IIFE pattern from classes <code>(function() { /* body */ })();</code>) as shown below:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> funcs = [];
<span class="hljs-comment">// create a bunch of functions</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) {
    (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> local = i;
        funcs.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
            <span class="hljs-built_in">console</span>.log(local);
        })
    })();
}
<span class="hljs-comment">// call them</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {
    funcs[j]();
}
</code></pre>
<p>Here the functions close over (hence called a <code>closure</code>) the <em>local</em> variable (conveniently named <code>local</code>) and use that instead of the loop variable <code>i</code>.</p>
<blockquote>
    <p>Note that closures come with a performance impact (they need to store the surrounding state).</p>
</blockquote>
<p>The ES6 <code>let</code> keyword in a loop would have the same behavior as the previous example:</p>
<pre><code class="lang-ts"><span class="hljs-keyword">var</span> funcs = [];
<span class="hljs-comment">// create a bunch of functions</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) { <span class="hljs-comment">// Note the use of let</span>
    funcs.push(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-built_in">console</span>.log(i);
    })
}
<span class="hljs-comment">// call them</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) {
    funcs[j]();
}
</code></pre>
<p>Using a <code>let</code> instead of <code>var</code> creates a variable <code>i</code> unique to each loop iteration.</p>
<h4 id="summary">Summary</h4>
<p><code>let</code> is extremely useful to have for the vast majority of code. It can greatly enhance your code readability and decrease the chance of a programming error.</p>
<p><a href="https://github.com/olov/defs/blob/master/loop-closures.md" target="_blank"></a></p>
</body>
</html>